# 1 基础语法
## 1.1 搭建 R 环境及常用操作
### 1.1.1 搭建R环境
### 1.1.2 常用操作
# 安装包
install.packages("openxlsx")
devtools::install_github("tidyverse/dplyr") 
remotes::install_github("tidyverse/dplyr")

# 加载包 
library(openxlsx)

# 更新包 
update.packages("openxlsx") 
update.packages() #更新所有包

# 删除包
remove.packages("openxlsx")

# 获取或设置当前路径 getwd()
setwd("D:/R-4.2.2/tests")

# 赋值
x <- 1:10
x+2

# 基本运算
# 数学运算
# + - * /、^(求幂)、%%(按模求余1)、%/%(整除)。
# 比较运算
# >、<、>=、<=、==、!=;
# identical(x,y)— 判断两个对象是否严格相等;
# all.equal(x,y)或 dplyr::near(x,y)— 判断两个浮点数是否近似相等 (误差为 1.5e−8)。
# 逻辑运算
## | (或)、 & (与)、! (非)、xor()(异或)

# 基本数据类型
# R 的基本数据类型
# numeric— 数值型，又分为integer(整数型)和double(浮点型); 
# logical— 逻辑型，只有TRUE和FALSE，或T和F;
# character— 字符型，引号1括起来的若干字符。
# R 中用 NA 表示缺失值，NULL 表示空值，NaN 表示非数，Inf 表示无穷大。
# 对于 R 中的大多数函数，NA 具有“传染性”，即 NA 参与的运算，结果会变成 NA。R 自
# 带的很多函数都提供 na.rm 参数设置，以便于设定计算时是否忽略缺失值。 
# 特别要注意:判断 x 是否为 NA，不是用 x==NA，而是用 is.na(x)。
# 可用函数 class(x) / typeof(x) / mode(x)查看对象 x 的类型。
# 在展现数据的细节方面，mode()性能最弱，class()性能一般，typeof()性 能最强。
# str(x)可以显示对象x的结构

# 保存和载入数据
save(x, file = "data/dat.Rda")
load("data/dat.Rda")

# 清屏和清除内存变量
# 按“Ctrl + L”组合键或单击命令窗口右上角的“小刷子”图标可对命令窗口清屏。 
# 若要清除当前变量，使用以下命令:
rm(x) # 清除变量x 
rm(list = ls(all = TRUE)) # 清除所有当前变量


## 1.2 数据结构:向量、矩阵、多维数组
# 数据结构是为了便于存储不同类型的数据而设计的数据容器。
# 学习数据结构，就是要把各 个数据容器的特点、适合存取什么样的数据理解透彻

### 1.2.1 向量(一维数据)
# 常用的向量有数值向量、逻辑向量、字符向量
# 1.数值向量
# 数值向量就是由数值组成的向量，单个数值是长度为 1 的数值向量，例如:
x = 1.5

#我们可以用 numeric()创建一个全为 0 的指定长度的数值向量，如下所示:
numeric(10)

#在 R 中经常用函数 c()将多个对象合并到一起: 
c(1, 2, 3, 4, 5)
c(1, 2, c(3, 4, 5)) # 将多个数值向量合并成一个数值向量 

#创建等差的数值向量，用:或者函数 seq()，基本格式为: 
seq(from, to, by, length.out, along.with, ...)
# from:设置首项(默认为 1)
# to:设置尾项
# by:设置等差值(默认为 1 或 −1)
# length.out:设置序列长度
# along.with:以该参数的长度作为序列长度
1:5 # 同seq(5)或seq(1,5)
seq(1, 10, 2) # 从1开始, 到10结束, 步长为2
seq(3, length.out=10)

# 创建重复的数值向量用函数 rep()，基本格式为: 
# rep(x, times,length.out, each, ...)
# x:为要重复的序列
# times:设置序列的重复次数
# length.out:设置所产生的序列的长度
# each:设置每个元素分别重复的次数(默认为 1)
x = 1:3
rep(x, 2)
rep(x, each = 2)
rep(x, c(2, 1, 2))
rep(x, each = 2, length.out = 4)
rep(x, times = 3, each = 2)

# 向量可以做“+、−、*、/”四则运算，即对应元素分别做运算的向量化运算
# 注意，将 R中两个不同长度的向量做运算，短的会自动循环补齐以配合长的
2:3 + 1:5

# 2.逻辑向量
# 逻辑向量是由逻辑值(TRUE 或 FALSE，或简写为 T 或 F)组成的向量。
# 对向量做逻辑运算，得到的结果是逻辑向量:
c(1, 2) > c(2, 1) # 等价于c(1 > 2, 2 > 1)
c(2,3)>c(1,2,-1,3) #等价于c(2>1,3>2,2>-1,3>3) 

# 除了比较运算符外，还可以用 %in% 判断元素是否属于集合:
c(1, 4) %in% c(1, 2, 3) # 左边向量每一个元素是否属于右边集合

# 在构造筛选行的条件时，经常有人用错语法，请参考以下规则
# %in% 表示属于，用于判断(左边)元素是否属于(右边)集合
# == 表示等于，用于判断(左边)元素是否等于(右边)元素

# 3.字符向量
# 字符(串)向量，是由一组字符串组成的向量，在 R 中单引号和双引号都可以用来生成字 
# 符向量。
"hello, world!"
c("Hello", "World")
c("Hello", "World") == "Hello, World"

#要想字符串中出现单引号或双引号，可以将单双引号错开，
#或者用转义字符“\”来做转义， 用 writeLines()函数输出纯字符串内容，如下所示:
'Is "You" a Chinese name?'
writeLines("Is \"You\" a Chinese name?")

#4.访问向量子集
# 访问向量子集即访问向量的一些特定元素或者某个子集
# 注意，R 中的索引是从 1 开始的
# 使用元素的位置来访问，形式如下所示:
v1 = c(1, 2, 3, 4)
#也可以访问任意位置的数值向量，但是注意索引不能既有正数又有负数:
v1[2] # 第2个元素
v1[2:4] # 第2~4个元素
v1[-3] # 除了第3个之外的元素
v1[c(1,3)]
v1[c(1, 2, -3)] # 报错 访问不存在的位置也是可以的，此时返回 NA:
v1[3:6]

#使用逻辑向量来访问，输入与向量相同长度的逻辑向量，以此决定每一个元素是否要被获取:
v1[c(TRUE, FALSE, TRUE, FALSE)] 

#这可以引申为“根据条件访问向量子集”:
v1[v1 <= 2] # 同v1[which(v1 <= 2)]或subset(v1, v1<=2) v1[v1 ^ 2 - v1 >= 2]
which.max(v1) # 返回向量v1中最大值所在的位置
which.min(v1) # 返回向量v1中最小值所在的位置


#5.为向量子集赋值，替换相应元素
#为向量子集赋值，就是先访问到向量子集，再赋值
v1[2:4] = c(0, 1, 3)
v1[c(TRUE, FALSE, TRUE, FALSE)] = c(3, 2)
v1[v1 <= 2] = 0
x[c("a", "a", "c")] # 重复访问也是可以的 x["d"] # 访问不存在的名字
v1[2] = 0
#注意，若对不存在的位置赋值，前面将用 NA 补齐: 
v1[10] = 8
v1

#6.为向量元素命名 
#你可以在创建向量的同时对其每个元素命名，代码如下:
x = c(a = 1, b = 2, c = 3)
x

#命名后，就可以通过名字来访问向量元素，代码如下:
x[c("a", "c")]
#获取向量元素的名字，代码如下:
names(x)

#更改向量元素的名字，代码如下:
names(x) = c("x", "y", "z")
x["z"]

#移除向量元素的名字，代码如下:
names(x) = NULL
x

# [] 与[[]] 的区别
# [ ]可以提取对象的子集，[[ ]]可以提取对象内的元素。 二者的区别:以向量为例，可以
# 将一个向量比作 10 盒糖果，你可以使用[ ]获取其中的 3 盒糖果，使用 [[ ]]打开盒子
# 并从中取出一颗糖果。对于未对元素命名的向量，使用[ ]和[[ ]]取出一个元素会产生相
# 同的结果。但对于已对元素命名的 向量，二者会产生不同的结果，如下所示:
#   x = c(a = 1, b = 2, c = 3)
# x["a"] # 取出标签为"a"的糖果盒
# ## a ## 1
# x[["a"]] # 取出标签为"a"的糖果盒里的糖果
# ## [1] 1
# 由于[[ ]]只能用于提取出一个元素，不适用于提取多个元素的情况，因此[[ ]]不能用于
# 负整数，负 整数意味着提取除特定位置之外的所有元素。 使用含有不存在的位置或名称
# 来创建向量子集时将会产生缺失值。但当使用[[ ]]提取一个位置超出范 围或者对应名称
# 不存在的元素时，该命令将会无法运行并产生错误信息。 例如，以下三个语句会报错:
#   x[[c(1, 2)]]
# x[[-1]]
# x[["d"]]

# 7.对向量排序
#向量排序函数 sort()，基本格式为:
# sort(x, decreasing, na.last, ...)
# x:为排序对象(数值型或字符型)
# decreasing:默认为 FALSE 即升序，TRUE 为降序
# na.last:默认为 FALSE，若为 TRUE，则将向量中的 NA 值放到序列末尾
# 函数 order()可以返回元素排好序的索引，以其结果作为索引访问元素，正好是排好序的
# 向量
# 函数rank的返回值是该向量中对应元素的“排名”，参数“ties. method”用于设置相同值的
# 处理方法

x = c(1,5,8,2,9,7,4)
sort(x)
order(x) # 默认升序，排名第2的元素在原向量的在4个位置
x[order(x)] # 同sort(x)
rank(x) # 默认升序，第2个元素排在第4位
#函数 rev()可将序列进行反转，即把 1,2,3 变成 3,2,1。




### 1.2.2 矩阵(二维数据) 
#矩阵是用两个维度表示和访问的向量。因此，适用于向量的性质和方法大多也适用于矩阵
#矩阵也要求元素是同一类型，如数值矩阵、逻辑矩阵等

#1.创建矩阵
#函数 matrix()将一个向量创建为矩阵，其基本格式为:
# matrix(x, nrow, ncol, byrow, dimnames, ...)
# x:为数据向量作为矩阵的元素;
# nrow:设定行数;
# ncol:设定列数;
# byrow:设置是否按行填充，默认为 FALSE(按列填充); 
# dimnames:用字符型向量表示矩阵的行名和列名

matrix(c(1, 2, 3,
         4, 5, 6,
         7, 8, 9), nrow = 3, byrow = FALSE)

matrix(c(1, 2, 3,
         4, 5, 6,
         7, 8, 9), nrow = 3, byrow = TRUE)

#为矩阵的行列命名:
matrix(1:9, nrow = 3, byrow = TRUE,
         dimnames = list(c("r1","r2","r3"), c("c1","c2","c3")))

#也可以创建后再命名:
m1 = matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3)
rownames(m1) = c("r1", "r2", "r3")
colnames(m1) = c("c1", "c2", "c3")

#特殊矩阵:
  diag(1:4, nrow = 4) # 对角矩阵

#函数 as.vector()可将矩阵转化为向量，其元素是按列读取的。

# 2.访问矩阵子集 
#矩阵是用两个维度表示和访问的向量，可以用一个二维存取器[,]来访问，
#这类似于构建向量子集时用的一维存取器[]。 我们可以为每个维度提供一个向量来确定一
#个矩阵的子集
#方括号中的第 1 个参数是行选择器，第 2 个参数是列选择器
#与构建向量子集一样，我们可以在两个维度中使用数值向量、 逻辑向量和字符向量
m1[1,2] # 提取第1行，第2列的单个元素
m1[1:2, 2:4] # 提取第1至2行，第2至4列的元素
m1[c("r1","r3"), c("c1","c3")] # 提取行名为r1和r3，列名为c1和c3的元素

#若一个维度空缺，则选出该维度的所有元素:
#负数表示在构建矩阵子集时可排除该位置，这和向量中的用法一致:
#注意，矩阵是用两个维度表示和访问的向量，但它本质上仍然是向量。因此，向量的一维
#存取器也可以用来构建矩阵子集:
m1[3:7]

#由于向量只包含相同类型的元素，矩阵也是如此，因此它们的操作方式也相似。若输入一 
#个不等式，则返回同样大小的逻辑矩阵:
m1 > 3

#根据逻辑矩阵可以选择矩阵元素或赋值:
m1[m1 > 3] # 注意选出来的结果是向量 

# 3.矩阵运算
#A+B，A-B，A*B，A/B:矩阵四则运算要求矩阵同型，类似 MATLAB 中的点运算，
#分别将对应位置的元素做四则运算;
#A %*% B:矩阵乘法要求矩阵 A 的列数等于矩阵 B 的行数



# 1.2.3 多维数组(多维数据)
# 具体来说，多维数组就是一个维度更高(通常大于 2)、可访问的向量，是向量/矩阵向更
# 高维度的自然推广
# 多维数组也要求元素是同一类型

#1.创建多维数组
#用函数 array()将一个向量创建为多维数组，基本格式为:
# array(x, dim, dimnames, ...)
# x:为数据向量作为多维数组的元素
# dim:设置多维数组各维度的维数
# dimnames:设置多维数组各维度的名称
a1 = array(1:24, dim = c(3, 4, 2))
a1

#也可以在创建数组时对每个维度进行命名:
a1 = array(1:24, dim = c(3, 4, 2),dimnames=list(c("r1","r2","r3"),
                                                c("c1","c2","c3","c4"), 
                                                c("k1","k2")))

#或者创建之后再命名1:
a1 = array(1:24, dim = c(3, 4, 2))
dimnames(a1) = list(c("r1","r2","r3"),
                    c("c1","c2","c3","c4"), c("k1","k2"))

# 2.访问多维数组子集
# 第 3 个维度姑且称为“页”:
# 在想象多维数组时，为了便于形象地理解，可以将其维度依次想象成与“书”相关的概念:
# 行、列、页、
# 本、层、架、室......
a1[2,4,2]
a1["r2","c4","k2"]
a1[1,2:4,1:2]
a1[,,2]
dim(a1)
# 提取第2行,第4列,第2页的元素
# 提取第r2行,第c4列,第k2页的元素
# 提取第1行,第2至4列,第1至2页的元素 # 提取第2页的所有元素
# 返回多维数组a1的各维度的维数



## 1.3 数据结构:列表、数据框、因子
### 1.3.1 列表
# 列表(list)可以包含不同类型的对象，甚至可以包括其他列表。列表的灵活性使得它非常有用。
# 例如，用 R 拟合一个线性回归模型，其返回结果就是一个列表，其中包含了线性回归的详细结果，
# 如线性回归系数(数值向量)、残差(数值向量)、QR 分解(包含一个矩阵和其他对象 的列表)等。
# 因为这些结果全都被打包到一个列表中，就可以很方便地提取所需信息，而无须 每次调用不同的函数。
# 列表最大的好处就是能够将多个不同类型的对象打包到一起，以便可以根据位置和名字访 问它们。

# 1.创建列表
# 可以用函数 list()创建列表。不同类型的对象可以放入同一个列表中。
# 例如，创建一个列表，包含 3 个成分:一个单元素的数值向量、一个两元素的逻辑向量和
# 一个长度为 3 的字符向量:

l0 = list(1, c(TRUE, FALSE), c("a", "b", "c"))
l0

#可以在创建列表时，为列表的每个成分指定名字:
l1 = list(A = 1, B = c(TRUE, FALSE), C = c("a", "b", "c"))
l1

#也可以创建列表后再对列表成分命名或修改名字:
names(l1) = NULL # 移除列表成分的名字 
names(l1) = c("x","y","z")

#2.从列表中提取成分的内容 
#提取列表中某成分下的内容，最常用的方法是用$，通过成分名字来提取该成分下的内容:
l1$y
l1$m # 访问不存在的成分m, 将会返回NULL

#也可以用[[n]]来提取列表第 n 个成分的内容，n 也可以换成成分的名字:
l1[[2]] # 同l1[["y"]] 
#用[[]]提取列表中某个成分的内容则更加灵活，可用在函数调用中，通过参数来传递成分
#的名字或索引:

#3.提取列表子集
# R 语言也经常需要从列表中提取多个成分及其内容，由这些成分组成的列表构成了原列表
# 的一个子集。就像提取向量和矩阵的子集一样，提取一个列表子集是用[]，可以取出列表
# 中的一些成分， 作为一个新的列表。在[]中可以用字符向量表示成分名字，用数值向量
# 表示成分位置，或用逻辑向量指定是否 选择来取出列表成分。

l1["x"] # 同l1[1]
l1[c("x", "z")] # 同 l1[c(1, 3)], l1[c(TRUE, FALSE, TRUE)]
# 总之，[]用于提取对象的子集，类型仍是该对象;[[]]用于提取对象的内容(即下一级元素)

# 4.为列表的成分赋值
# 即先访问(提取)到列表的成分，再赋以相应的值。注意，若给一个不存在的成分赋值， 
# 列表会自动地在对应名称或位置下增加一个新成分

l1$x = 0 # 将列表的成分x赋值为0 
#也可以同时给多个列表成分赋值:
l1[c("x", "y")] = list(x = "new value for y", y = c(3, 1))
#若要移除列表中的某些成分，只需赋值为 NULL: 
l1[c("z", "m")] = NULL

#5.列表函数
#用函数 as.list()可将向量转换成列表:
l2 = as.list(c(a = 1, b = 2))
l2

#通过去列表化函数 unlist()可将一个列表打破成分界线，强制转换成一个向量1: 
unlist(l2)

# 为了方便操作列表，tidyverse 系列中的 purrr 包提供了一系列列表相关的函数，建议
# 读者查阅并使用。
# pluck():同[[]]提取列表中的元素。
# keep():保留满足条件的元素。
# discard():删除满足条件的元素。
# compact():删除列表中的空元素。
# append():在列表末尾增加元素。
# flatten():摊平列表(只摊平一层)。


# 1.3.2 数据框(数据表)
# R语言中用于统计分析的样本数据，都是按数据框类型操作的
# 数据框是指有若干行和列的数据集，它与矩阵类似，但并不要求所有列都是相同的类型
# 本质上讲，数据框就是一个列表，它的每个成分都是一个向量，并且长度相同，以表格的形式展现
# 总之，数据框是由列向量组成、有着矩阵形式的列表
# 数据框与常见的数据表是一致的:每一列代表一个变量属性，每一行代表一条样本数据

# R 中自带的数据框是 data.frame，建议改用更现代的数据框:tibble1。
# Hadley 在 tibble 包中引入了一种 tibble 数据框，以代替 data.frame，
# 而且 tidyverse 包都是基于 tibble 数据框的。
# tibble 对比 data.frame 的优势如下所示。
# tibble()比 data.frame()做的更少:不改变输入变量的类型，不会改变变量名，不会创建行名。
# tibble对象的列名可以是R中的“非法名”:非字母开头、包含空格，但定义和使用
# 变量时都需要用反引号`括起来
# tibble 在输出时不自动显示所有行，避免数据框较大时显示出很多内容
# 用[]选取列子集时，即使只选取一列，返回结果仍是 tibble，而不自动简化为向量

#1.创建数据框
#用 tibble()根据若干列向量创建 tibble:
library(tidyverse) # 或tibble 
persons = tibble(
Name = c("Ken", "Ashley", "Jennifer"),
Gender = c("Male", "Female", "Female"),
Age = c(24, 25, 23),
Major = c("Finance", "Statistics", "Computer Science"))
persons

#用 tribble()通过按行录入数据的方式创建 tibble:
tribble(
  ~Name, ~Gender, ~Age, ~Major,
  "Ken", "Male", 24, "Finance",
  "Ashley", "Female", 25, "Statistics",
  "Jennifer", "Female", 23, "Computer Science")

#用 as_tibble()可将 data.frame 和 matrix 这种各成分等长度的 list 转换为 tibble
#将不等长的列表转化为数据框:
a = list(A = c(1, 3, 4), B = letters[1:4])
a

# lengths()获取list中每个成分的长度
map_dfc(a, `length<-`, max(lengths(a))) # map循环参阅1.6.2节

#数据框既是列表的特例，也是广义的矩阵，因此访问这两类对象的方式都适用于数据框
#例如与矩阵类似，对数据框的各列重命名，代码如下:
df = tibble(id = 1:4,
              level = c(0, 2, 1, -1),
              score = c(0.5, 0.2, 0.1, 0.5))
  
names(df) = c("id", "x", "y")

df

#2.提取数据框的元素、子集
#数据框是由列向量组成、有着矩阵形式的列表，可以用两种操作方式来访问数据框的元素和子集

#(1)以列表方式提取数据框的元素、子集 若把数据框看作由向量组成的列表，则可以沿用列表的操作方式来提取元素或构建子集
#例如，可以用 $ 按列名来提取某一列的值，或者用[[]]按照位置或列名提取。 
#例如，提取列名为 x 的值，并得到向量:

df$x # 同df[["x"]], df[[2]] 

#以列表形式构建子集完全适用于数据框，同时也会生成一个新的数据框
#提取子集的操作 符[]允许用数值向量表示列的位置，用字符向量表示列名，或用逻辑向量指定是否选择
#例如，提取数据框的一列或多列，可以得到子数据框:
df[1] # 提取第1列, 同df["id"]

df[1:2] # 同df[c("id","x")], df[c(TRUE,TRUE,FALSE)]
  
#(2)以矩阵方式提取数据框的元素、子集 以列表形式操作并不支持行选择，以矩阵形式操作则更加灵活
#若将数据框看作矩阵，其二维形式的存取器可以很容易地获取一个子集的元素，同时支持列选择和行选择
#换句话说，可以使用[i, j]指定行或列来提取数据框子集，[,]内可以是数值向量、字符向量或者逻辑向量
#若行选择器为空，则只选择列(所有行):
df[, "x"]
df[,c("x","y")]
# 同df[,2:3]

#若列选择器为空，则只选择行(所有列):
df[c(1,3),]

#同时选择行和列:
df[1:3, c("id","y")]

#根据条件筛选数据。例如用y >= 0.5筛选df的行，并选择id和y两列:
df[df$y >= 0.5, c("id","y")]

#按列名属于集合{x, y, w}来筛选df的列，并选择前两行: 
ind = names(df) %in% c("x","y","w")
df[1:2, ind]


#3.给数据框赋值
#给数据框赋值就是选择要赋值的位置，再准备好同样大小且格式匹配的数据，
#赋值给那些位置即可，同样有列表方式和矩阵方式

#(1)以列表方式给数据框赋值
#用 $ 或[[ ]]对数据框的某列赋值
df$y = c(0.6,0.3,0.2,0.4) # 同df[["y"]] = c(0.6,0.3,0.2,0.4)
#利用现有列，创建(计算)新列:
df$z = df$x + df$y
df

df$z = as.character(df$z) # 转换列的类型 df

#用[]可以对数据框的一列或多列进行赋值: 
df["y"] = c(0.8,0.5,0.2,0.4)
df[c("x", "y")] = list(c(1,2,1,0), c(0.1,0.2,0.3,0.4))

#(2)以矩阵方式给数据框赋值 以列表方式对数据框进行赋值时，也是只能访问列
#若需要更加灵活地进行赋值操作，可以通过矩阵方式进行
df[1:3,"y"] = c(-1,0,1)
df[1:2,c("x","y")] = list(c(0,0), c(0.9,1.0))

#4.一些有用的函数
#把函数 str()或 glimpse()作用在 R 对象上，可以显示该对象的结构:
str(persons)

#把 summary()作用在数据框或列表上，将生成各列或各成分的汇总信息: 
summary(persons)

#我们经常需要将多个数据框(或矩阵)按行或按列进行合并
#用函数 rbind()增加行(样本数据)，要求宽度(列数)相同
#用 cbind()函数增加列(属性变量)，要求高度(行数) 相同
#例如，向 persons 数据框中添加一个新记录: 
rbind(persons,
      tibble(Name = "John", Gender = "Male",
            Age = 25, Major = "Statistics"))

#向 persons 数据框中添加两个新列，分别表示每个人是否已注册及其手头的项目数量:
cbind(persons, Registered = c(TRUE, TRUE, FALSE), Projects = c(3, 2, 3))

#rbind()和 cbind()不会修改原始数据，而是生成一个添加了行或列的新数据框
#函数 expand.grid()可生成多个属性水平值的所有组合(笛卡儿积)形式的数据框: 
expand.grid(type = c("A","B"), class = c("M","L","XL"))


#1.3.3 因子
#数据(变量)可划分为:定量数据(数值型)、定性数据(分类型)，定性数据又分为名义型
#(无好坏顺序之分，如性别)、有序型(有好坏顺序之分，如疗效)
#R提供了因子(factor)这一数据结构(容器)，专门用来存放名义型和有序型的分类变量
#因子本质上是一个带有水平(level)属性的整数向量，其中“水平”是指事前确定可能取值的有限集合
#例如，性别有两个水平属性:男、女
#直接用字符向量也可以表示分类变量，但它只有字母顺序，不能规定想要的顺序，也不能表达有序分类变量
#所以，有必要把字符型的分类变量转化为因子型，这更便于对其做后续描述汇总、可视化、建模等
#1.创建与使用因子

# 函数 factor()用来创建因子，基本格式为:
# factor(x, levels, labels, ordered, ...)
# x:为创建因子的数据向量
# levels:指定因子的各水平值，默认为 x 中不重复的所有值
# labels:设置各水平名称(前缀)，与水平名称一一对应
# ordered:设置是否对因子水平排序，默认 FALSE 为无序因子，TRUE 为有序因子
# 该函数还包含参数 exclude:指定有哪些水平是不需要的(设为 NA)
# nmax 用于设定水平数的上限
# 若不指定参数 levels，则因子水平默认按字母顺序
# 比如，现有 6 个人的按等级划分的成绩数据，先以字符向量创建，并对其排序: 
x = c("优", "中", "良", "优", "良", "良") # 字符向量 x
sort(x) # 排序是按字母顺序

#它的顺序只能是字母顺序，如果想规定顺序:中、良、优，
#正确的做法就是创建因子，用 levels 指定想要的顺序:
x1 = factor(x, levels = c("中", "良", "优")) # 转化因子型
x1

as.numeric(x1) # x的存储形式: 整数向量

# 注意，不能直接将因子数据当字符型操作，需要用 as.character()转化
# 转化为因子型后，数据向量显示出来(外在表现)与原来是一样的，但这些数据的内在存 储已经变了
# 因子的内在存储与外在表现如图 1.8 所示
# 因子型是以整数向量存储的，将各水平值按照规定的顺序分别对应到整数
# 将原向量的各个值分别用相应的整数存储，输出和使用的时候再换回对应的水平值
# 整数是有顺序的，这样就相当于在不改变原数据的前提下规定了顺序，同时也节省了存储空间
# 注意，标签(labels)是因子水平(levels)的别名
# 变成因子型后，无论是排序、统计频数、绘图等，都有了顺序:
sort(x1)

table(x1)

ggplot(tibble(x1), aes(x1)) +
  geom_bar()

#所生成的条形图结果如图 1.9 所示，x 轴的条形顺序是想要的中、良、优
#图 1.8 因子的内在存储与外在表现 图 1.9 用因子控制条形顺序

#用 levels()函数可以访问或修改因子的水平值，这也将改变数据的外在表现:
levels(x1) = c("Fair", "Good", "Excellent") # 修改因子水平 x1
x1

#有时候你可能更希望让水平的顺序与其在数据集中首次出现的次序相匹配，这时可以设置 参数levels = unique(x)
#转化为因子型的另一个好处是，可以“识错”:因子数据只认识出现在水平值中的值，对于 未出现在水平值中的值将被识别为 NA
#很多人将因子固有的顺序与有序因子混淆，二者不是一回事:上述反复提到的顺序，可称 为因子固有的顺序，
#正是有了它，才能方便地按想要的顺序进行排序、统计频数、绘图等;
#而无序因子与有序因子，是与变量本身的数据类型相对应的，名义型(无顺序好坏之分的分类变 量)用无序因子存放，
#有序型(有顺序好坏之分的分类变量)用有序因子存放，该区分是用于 不同类型的数据，建模时适用不同的模型
#示例的成绩数据是有好坏之分的，因此创建为有序因子: 
x2 = factor(x, levels = c("中", "良", "优"),ordered = TRUE)
x2
#如果对 x2 做排序、统计频数、绘图，你会发现与使用无序因子时没有任何区别，它们的区 别体现在对其建模时所适用的模型不同

#2.有用函数
# 函数 table()可以统计因子各水平的出现次数(频数)，也可以统计向量中每个不同元素的出现次数，其
# 返回结果为命名向量
table(x)

# 函数 cut()，用来做连续变量离散化:将数值向量切分为若干区间段，并返回因子
# 基本格式为: 
# cut(x, breaks, labels, ...)
# x:要切分的数值向量
# breaks:切分的界限值构成的向量，或表示切分段数的整数
# 该函数还包含参数 right 用于设置区间段是否左开右闭
# include.lowest 用于设置是否包含下界
# ordered_result 用于设置是否对结果因子排序

Age = c(23,15,36,47,65,53)
cut(Age, breaks = c(0,18,45,100),
    labels = c("Young","Middle","Old"))

#函数 gl()用来生成有规律的水平值组合因子。对于多因素试验设计，用该函数可以生成多个因素完全组合
#基本格式为:
# gl(n, k, length, labels, ordered, ...)
# n:为因子水平个数
# k:为同一因子水平连续重复次数
# length:为总的元素个数，默认为 n*k，若不够则自动重复
# labels:设置因子水平值
# ordered:设置是否为有序，默认为 FALSE

tibble(
  Sex = gl(2, 3, length = 12, labels = c("男","女")),
  Class = gl(3, 2, length = 12, labels = c("甲","乙","丙")),
  Score = gl(4, 3, length = 12, labels = c("优","良","中", "及格")))

#3.forcats 包
# tidyverse 系列中的 forcats 包是专门为处理因子型数据而设计的，forcats 包提供了 一系列操作因子的方便函数
# as_factor():转化为因子，默认按水平值的出现顺序
# fct_count():计算因子各水平频数、占比，可按频数排序 
# fct_c():合并多个因子的水平
# 改变因子水平的顺序
# fct_relevel():手动对水平值重新排序
# fct_infreq():按高频优先排序
# fct_inorder():按水平值出现的顺序排序
# fct_rev():将顺序反转
# fct_reorder():根据其他变量或函数结果排序(绘图时有用)
# 修改水平
# fct_recode():对水平值逐个重编码
# fct_collapse():按自定义方式合并水平
# fct_lump_*():将多个频数小的水平合并为其他
# fct_other():将保留之外或丢弃的水平合并为其他
# 增加或删除水平
# fct_drop():删除若干水平
# fct_expand:增加若干水平
# fct_explicit_na():为NA设置水平

# 读者需要明白这样一个基本逻辑:操作因子是操作一个向量，该向量更多的时候是以数据 框的一列的形式存在的
# 我们来演示一下更常用的操作数据框中的因子列的方法，这会涉及数据操作和绘图的语法，这部分知识在第 2~3 章才会讲到
# 你只需要知道大意并理解因子操作部 分即可

# mpg 列是汽车数据集，class 列是分类变量车型，先统计各种车型的频数，共有 7 类;
# 对该列做因子合并，合并为 5 类+Other 类，再统计频数，这里将频数少的类合并为 Other 类:
count(mpg, class)

mpg1 = mpg %>%
  mutate(class = fct_lump(class, n = 5))
  count(mpg1, class)

#若直接对 class 各类绘制条形图，是按水平顺序，此时频数会参差不齐;
#改用根据频数多 少进行排序，则条形图变得整齐易读，对比效果见图 1.10。
  p1 = ggplot(mpg, aes(class)) +
   mutate(class = fct_lump(class, n = 5))
  count(mpg1, class)
  geom_bar() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
  p2 = ggplot(mpg, aes(fct_infreq(class))) +
    geom_bar() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
  library(patchwork)
  p1 | p2
  

#1.4 数据结构:字符串、日期时间
# 1.4.1 字符串
# 字符串是用双引号或单引号括起来的若干字符，建议用双引号，除非字符串中包含双引号。 
# 字符串构成的向量，简称为字符向量。
# 字符串处理不是 R 语言的主要功能，但也是必不可少的，数据清洗、可视化等操作都会用到。
# tidyverse 系列中的 stringr 包提供了一系列接口一致的、简单易用的字符串操作函数， 
# 足以代替 R 自带的字符串函数。这些函数都是向量化的，即作用在字符向量上，
# 对字符向量中 的每个字符串做某种操作。

library(stringr)
  
#1.字符串的长度(即包含字符个数)
str_length(c("a", "R for data science", NA)) 
str_pad(c("a", "ab", "abc"), 3)
str_trunc("R for data science", 10)
str_trim(c("a  ", "b  ", "a b"))

#后三个函数都包含参数side=c("both", "left", "right")用于设定操作的方向。 

#2.字符串合并
str_c(..., sep = "", collapse = NULL) 
# sep:设置间隔符，默认为空字符;
# collapse:指定间隔符，将字符向量中的所有字符串合并为一个字符串。
str_c("x", 1:3, sep = "") # 同 paste0("x", 1:3), paste("x", 1:3, sep="")
str_c("x", 1:3, collapse = "_")
str_c("x", str_c(sprintf("%03d", 1:3)))
#注意，上述代码中的 1:3 自动向下兼容以适应字符串运算，效果同 c("1","2","3")。 
#将字符串重复 n 次，基本格式为:
#str_dup(string, times) string:为要重复的字符向量
#times:为重复的次数
str_dup(c("A","B"), 3)
str_dup(c("A","B"), c(3,2))

#3.字符串拆分
str_split(string, pattern) # 返回列表 
str_split_fixed(string, pattern, n) # 返回矩阵，n控制返回的列数
#string:要拆分的字符串
#pattern:指定拆分的分隔符，可以是正则表达式
x = "10,8,7"
str_split(x, ",")
str_split_fixed(x, ",", n = 2)

#4.字符串格式化输出
#只要在字符串内使用“{变量名}”，那么函数 str_glue()和 str_glue_data 就可以将
#字符串中的变量名替换成变量值，后者的参数.x 支持引入数据框、列表等，相关的代码示例如下所示
str_glue("Pi = {pi}")

name = " 李明"
tele = "13912345678"
str_glue("姓名: {name}", "电话号码: {tele}", .sep=";")

df = mtcars[1:3,]
str_glue_data(df, "{rownames(df)} 总功率为 {hp} kW.") 

#5.字符串排序
#str_sort(x, decreasing, locale, ...)
#str_order(x, decreasing, locale, ...)
#默认 decreasing = FALSE 表示升序，前者返回排好序的元素，后者返回排好序的索引; 
#参数 locale 可设定语言，默认为 "en"(即英语)

x = c("banana", "apple", "pear")
str_sort(x)
str_order(x)
str_sort(c("香蕉", "苹果", "梨"), locale = "ch") 
  

#6.检测匹配
#str_detect(string, pattern, negate=FALSE)— 检测是否存在匹配
#str_which(string, pattern, negate=FALSE)— 查找匹配的索引
#str_count(string, pattern)— 计算匹配的次数
#str_locate(string, pattern)— 定位匹配的位置
#str_starts(string, pattern)— 检测是否以 pattern 开头
#str_ends(string, pattern)— 检测是否以 pattern 结尾
#string:要检测的字符串
#pattern:匹配的模式，可以是正则表达式
#negate:默认为 FALSE，表示正常匹配;若为 TRUE，则为反匹配(即找不匹配的情况)
x
str_detect(x, "p")
str_which(x, "p")
str_count(x, "p")
str_locate(x, "a.")

#7.提取字符串子集 
#根据指定的起始和终止位置提取子字符串，基本格式为:
str_sub(string, start = 1, end = -1)
#例如:
str_sub(x, 1, 3)
str_sub(x, 1, 5) # 若长度不够, 则尽可能多地提取 
str_sub(x, -3, -1)

#提取字符向量中匹配的字符串，基本格式为:
str_subset(string, pattern, negate=FALSE) 
#若 negate = TRUE, 则返回不匹配的字符串
str_subset(x, "p")

#8.提取匹配的内容 
#str_extract(string, pattern) 只提取匹配的内容
#str_match(string, pattern) 提取匹配的内容以及各个分组捕获，并返回矩阵，
#矩阵的每行对应于字符向量中的一个字符串，每行的第一个元素是匹配内容，
#其他元素是各个分组捕获，没有匹配则为NA

x = c("1978-2000", "2011-2020-2099")
pat = "\\d{4}" # 正则表达式, 匹配4位数字
str_match(x, pat)

#9.修改字符串 
#用新字符串替换查找到的匹配字符串
#做字符替换，基本格式为:
#str_replace(string, pattern, replacement) 
#pattern:要替换的子字符串或模式
#replacement:要替换为的新字符串
x
str_replace(x, "-", "/")

#10.其他函数 
#大小写转化
# str_to_upper():转换为大写
# str_to_lower():转换为小写
# str_to_title():转换标题格式(单词首字母大写)
str_to_lower("I love r language.")
str_to_upper("I love r language.")
str_to_title("I love r language.")
# str_conv(string, encoding):转化字符串的字符编码
# str_view(string, pattern, match):在 Viewer 窗口输出(正则表达式)模式匹配结果
# word(string, start, end, sep = " "):从英文句子中提取单词
# str_wrap(string, width = 80, indent = 0, exdent = 0):调整段落格式
  
#关于 stringr 包
#以上用于查找匹配的各个函数，只是查找第一个匹配，要想查找所有匹配，
#各个函数都有另一个版本(加 后缀_all)，例如 str_extract_all()
#以上各个函数中的参数 pattern 都支持用正则表达式(Regular Expression)表示模式
  
# 1.4.2 日期时间
#日期时间值通常以字符串形式传入 R 中，然后转化为以数值形式存储的日期时间变量
#R 的内部日期是以 1970 年 1 月 1 日至今的天数来存储，内部时间则是以 1970 年 1 月 1 日 零时至今的秒数来存储
#tidyverse 系列的 lubridate 包提供了更加方便的函数，可以生成、转换、管理日期时间数 据，足以代替 R 自带的日期时间函数

library(lubridate)
#1.识别日期时间
today()
now()
as_datetime(today()) # 日期型转日期时间型 
as_date(now()) # 日期时间型转日期型
#无论年、月、日、时、分、秒按什么顺序及以什么间隔符分隔，总能正确地识别成日期时 间值:
ymd("2020/03~01")
myd("03202001")
dmy("03012020")
ymd_hm("2020/03~011213")
#注意:根据需要可以任意组合(如 ymd_h/myd_hm/dmy_hms)，还可以用参数 tz ="..." 指定时区。 
#我们也可以用 make_date()和 make_datetime()从日期时间组件创建日期时间:
make_date(2020, 8, 27)
make_datetime(2020, 8, 27, 21, 27, 15)

# 2.格式化输出日期时间
# 用 format()函数输出日期时间:
d = make_date(2020, 3, 5)
format(d, '%Y/%m/%d')

#用 stamp()函数，按给定模板格式输出日期时间: 
t = make_datetime(2020, 3, 5, 21, 7, 15)

#3.提取日期时间数据的组件
# 日期时间数据中的“年、月、日、周、时、分、秒”等称为其组件
# 常用的日期时间组件 如表 1.2 所示
# 常用的日期时间组件
t = ymd_hms("2020/08/27 21:30:27")
t
year(t) # 当年的第几天
quarter(t) # 第几季度
month(t) 
day(t) 
yday(t) # 当年的第几天
hour(t) 
wday(t,label = TRUE) # 数值表示本周的第几天, 默认周日是第1天
tz(t) # 时区

#用with_tz()将时间数据转换为另一个时区的同一时间;
#用force_tz()将时间数据的 时区强制转换为另一个时区:
with_tz(t, tz = "America/New_York")
force_tz(t, tz = "America/New_York")
#还可以模糊提取(取整)不同的时间单位:
round_date(t, unit="hour") # 四舍五入取整到小时 
#注意:类似地，向下取整用 floor_date()，向上取整用 ceiling_date()
rollback(dates, roll_to_first=FALSE, preserve_hms=TRUE) #回滚到上月 最后一天或本月第一天。
  
#4.时间段数据
#interval():计算两个时间点的时间间隔，返回时间段数据。
begin = ymd_hm("2019-08-10 14:00")
end = ymd_hm("2020-03-05 18:15")
gap = interval(begin, end) # 同 begin %--% end gap
time_length(gap, "day")
time_length(gap, "minute")
t %within% gap
# 计算时间段的长度为多少天 # 计算时间段的长度为多少分钟 # 判断t是否属于该时间段
duration() #:用“数值+时间单位”存储时段的长度。
duration(100, units = "day")
int = as.duration(gap)
int

#period() 和 duration()基本相同,二者的区别:
#duration 基于数值线，不考虑闰年和闰秒
#period 基于时间线，考虑闰年和闰秒。
#比如，在 duration 中，1 年总是 365.25 天
#而在 period 中，平年有 365 天，闰年有 366 天
#固定单位的时间段
#period 时间段:years()、months()、weeks()、days()、hours()、minutes()、seconds()。
#duration 时间段:dyears()、dmonths()、dweeks()、ddays()、dhours()、dminutes()、dseconds()。
dyears(1)
years(1)

#5.日期的时间的计算 用“时间点+时间段”可以生成一个新的时间点:
t + int
leap_year(2020)#判断是否为闰年
ymd(20190305) + years(1) ## 加period的一年
ymd(20190305) + dyears(1) # 加duration的一年, 365天
t + weeks(1:3)

#除法运算:
gap / ddays(1) #除法运算, 同time_length(gap,'day')
gap %% ddays(1)
as.period(gap %% ddays(1))
#月份加运算:%m+%，表示日期按月数增加。例如，生成每月同一天的日期数据:
date = as_date("2019-01-01")
date %m+% months(0:11)

#用“pretty_dates()”可以生成近似的时间刻度:
x = seq.Date(as_date("2019-08-02"), by = "year", length.out = 2)
pretty_dates(x, 12)

#1.4.3 时间序列
# 为了研究某一事件的规律，依据时间发生的顺序将事件在多个时刻的数值记录下来，就构 成了一个时间序列，用Yt表示。
# 例如，国家或地区的年度财政收入、股票市场的每日波动、气象变化、工厂按小时观测的 产量等。
# 另外，随温度、高度等变化而变化的离散序列，也可以看作时间序列。
# 1.ts 对象
# Base R提供的ts数据类型是专门为时间序列设计的，一个时间序列数据其实就是一个数 值型向量，且每个数都有一个时刻与之对应。
# 用 ts()函数生成时间序列，基本格式如下: 
# ts(data, start=1, end, frequency=1, ...)
# data:数值向量或矩阵
# start:设置起始时刻
# end:设置结束时刻
# frequency:设置时间频率，默认为 1，表示一年有 1 个数据
date = as_date("2019-01-01")
date %m+% months(0:11)
ts(data = 1:10, start = 2010, end = 2019)
ts(data = 1:10, start = 2010, frequency = 4) # 季度数据

#同理，对于月度数据，frequency = 12;对于周度数据，frequency = 52;
#对于日度数据，frequency = 365。 

#2.tsibble
# fpp3 生态下的 tsibble 包提供了整洁的时间序列数据结构 tsibble
# 时间序列数据无非就是“指标数据+时间索引”(或者再加“分组索引”)
# 注意:多元时间序列就是包含多个指标列
# 分组时间序列数据首先是一个数据框，若有分组变量需采用“长格式”作为一列(长宽格 式及转化参见 2.4 节)
# 只需要指定时间索引、分组索引，就能变成时间序列数据结构

#例如，现有 3 个公司 2017 年的日度股票数据(tibble 格式)，其中存放 3 只股票的 Stock 列为分组索引:
load("data/stocks.rda")
stocks

#用 as_tsibble()将数据框转化为时间序列对象 tsibble, 只需要指定时间索引 (index)、分组索引(key):
library(fpp3)
stocks = as_tsibble(stocks, key = Stock, index = Date)
stocks

#tsibble 对象非常便于后续处理和探索: 
stocks %>%
    group_by_key() %>%
    index_by(weeks = ~ yearweek(.)) %>% # 周度汇总
    summarise(max_week = mean(Close))

autoplot(stocks) # 可视化

##1.5 正则表达式
# 正则表达式是根据字符串规律按一定法则，简洁地表达一组字符串的表达式。正则表达式 
# 通常就是从貌似无规律的字符串中发现规律，进而概括性地表达它们所共有的规律或模式，
# 以便于操作和处理它们，这是真正的化繁为简，以简驭繁的典范。
# 几乎所有的高级编程语言都支持正则表达式，正则表达式广泛应用于文本挖掘、数据预处 理，例如:
# 检查文本中是否含有指定的特征词;  找出文本中匹配特征词的位置;
# 从文本中提取信息;
# 修改文本。
# 正则表达式包括只能匹配自身的普通字符(如英文字母、数字、标点等)和
# 被转义了的特殊字符(称为“元字符”)

# 1.5.1 基本语法
# 1.常用的元字符
# 正则表达式中常用的元字符如表
# 表1.3常用的元字符
.   匹配除换行符“/n”以外的任意字符
\\  转义字符，匹配元字符时，使用“\\元字符”
|   表示或者，即“|”前后的表达式任选一个
^   匹配字符串的开始
$   匹配字符串的结束
( ) 提取匹配的字符串，即括号内的看作一个整体，即指定子表达式
[ ] 可匹配方括号内任意一个字符
{}  前面的字符或表达式的重复次数:{n}表示重复n次;{n,}表示重复n次到更多次;{n, m}表 示重复 n~m 次
*   前面的字符或表达式重复 0 次或更多次 
+   前面的字符或表达式重复 1 次或更多次 
?   前面的字符或表达式重复 0 次或 1 次

#其他编程语言中的转义字符一般是“\”。默认情况下，正则表达式区分大小写，要创建忽略 大小写的正则表达式，代码如下:
pat = fixed(pattern, ignore_case = TRUE)
#在多行模式下，^和$就表示行的开始和结束，创建多行模式的正则表达式的代码如下: 
pat = regex("^\\(.+?\\)$", multiline = TRUE)

#2.特殊字符类及其反义 正则表达式中常用的特殊字符及其反义
\\d 与\\D  匹配数字，匹配非数字
\\s 与\\S  匹配空白符，匹配非空白符
\\w 与\\W  匹配字母或数字或下划线或汉字，匹配非\w 字符
\\b 与\\B  匹配单词的开始或结束的位置，匹配非\b 的位置
\\h 与\\H  匹配水平间隔，匹配非水平间隔
\\v 与\\V  匹配垂直间隔，匹配非垂直间隔
[^...]     匹配除......以外的任意字符
\\S+:匹配不包含空白符的字符串
\\d:匹配数字，同[0-9]
[a-zA-Z0-9]:匹配字母和数字
[\\p{han}]或[\u4e00-\u9fa5]:匹配汉字
[^aeiou]:匹配除 aeiou 之外的任意字符，即匹配辅音字母

#3.POSIX 字符类
#正则表达式中还可以使用 POSIX 字符类
[[:lower:]] 小写字母
[[:upper:]] 大写字母
[[:alpha:]] 大小写字母
[[:digit:]] 数字
[[:alnum:]] 0~9 字母和数字
[[:blank:]] 空白符包括空格、制表符、换行符、中文全角空格等
[[:cntrl:]] 控制字符
[[:punct:]] 标点符号包括“!”“"”“#”“%”“&”“’”“()”“*”“+”“-”“.”“/”“:”“;”等"
[[:space:]] 空格字符:空格、制表符、垂直制表符、回车、换行符、换页符
[[:xdigit:]] 十六进制数字:0~9、A~F、a~f
[[:print:]] 打印字符:[[:alpha:]]、[[:punct:]]、[[:space:]] 
[[:graph:]] 图形化字符:[[:alpha:]]、[[:punct:]]

#4.运算优先级
# 圆括号括起来的表达式最优先，其次是表示重复次数的操作(即“*”“+”“{ }”);
# 再次 是连接运算(即几个字符放在一起，如 abc);最后是或运算(|)。
# 另外，正则表达式还有若干高级用法，常用的有零宽断言和分组捕获

# 1.5.2 若干实例 
# 以上正则表达式语法组合起来使用，就能产生非常强大的匹配效果，对于匹配到的内容，
# 根据需要可以提取它们，也可以替换它们。
#正则表达式与 stringr 包连用
# 若只是调试和查看正则表达式的匹配效果，可用 str_view()及其_all 后缀版本，
#   匹配结果将在 RStudio 的 Viewer 窗口显示，在原字符向量中高亮显示匹配内容，非常直观。 
# 若要提取正则表达式匹配到的内容，则用 str_extract()及其_all 后缀版本。 
# 若要替换正则表达式匹配到的内容，则用 str_replace()及其_all 后缀版本。
# 使用正则表达式关键在于能够从貌似没有规律的字符串中发现规律性，再将规律性用正则 表达式语法表示出来。
# 下面看几个正则表达式比较实用的实例。

#例1.1 直接匹配
# 该方法适合想要匹配的内容具有一定规律性，该规律性可用正则表达式表示出来。
# 比如， 数据中包含字母、符号、数值，我们想提取其中的数值，
# 可以按正则表达式语法规则直接把要 提取的部分表示出来:
x = c("CDK弱(+)10%+", "CDK(+)30%-", "CDK(-)0+", "CDK(++)60%*")
str_view(x, "\\d+%")
str_view(x, "\\d+%?")
# str_view()常用于调试正则表达式，匹配结果显示在 Viewer 窗口
# \\d 表示匹配一位数字，
# +表示前面数字重复 1 次或多次，%原样匹配%。 
# 若后面不加“?”则必须匹配到%才会成功，故第 3 个字符串就不能成功匹配;
# 若后面加上“?”则表示匹配前面的% 0 次或 1 次，从而能成功匹配到第 3 个字符串。

# 例1.2 用零宽断言匹配两个标志之间的内容
# 该方法适合想要匹配的内容没有规律性，但该内容位于两个有规律性的标志之间，标志也可以是开始和结束。
# 通常想要匹配的内容不包含两边的“标志”，这就需要用零宽断言。简单来说，就是引导语法既要匹配到“标志”，但又不包含“标志”。
# 左边标志的引 导语法是(?<=标志)，右边标志的引导语法是(?=标志)，而把真正要匹配的内容放在它们中间。
# 比如，来自问卷星“来自 IP”数据，想要提取 IP 和地址信息。
x = c("175.10.237.40(湖南-长沙)", "114.243.12.168(北京-北京)", "125.211.78.251(黑龙江-哈尔滨)")
# 提取省份
str_extract(x, "\\(.*-") # 此处作为对比，不用零宽断言
str_extract(x, "(?<=\\().*(?=-)") # 用零宽断言
# 提取IP
str_extract(x, "\\d.*\\d") # 直接匹配 
str_extract(x, "^.*(?=\\()") # 用零宽断言

# 省份(或直辖市)位于两个标志“(”和“-”之间，但又不包含该标志，这就需要用到零宽断言。
# IP 位于两个标志“开始”和“(”之间，左边用开始符号^，右边用零宽断言。
                                  
#再比如，用零宽断言提取专业信息(位于“级”和数字之间):
x = c("18级能源动力工程2班", "19级统计学1班") 
str_extract(x, "(?<=级).*?(?=[0-9])")

#再看两个的复杂的零宽断言，涉及出现次数。例如，提取句子中的最后一个单词:
x = c("I am a teacher", "She is a beautiful girl")
str_extract(x, "(?<= )[^ ]+$")

#零宽断言以空格为左标志，匹配内容是非空格出现 1 次或多次直到结尾，
#结果就是作为左标志的空格只能是句子中的最后一个空格
#再比如，提取以“kc/”为左标志，直到第 3 个下划线之前的内容:
x = "D:/paper/1.65_kc_ndvi/kc/forest_kc_historical_ACCESS-ESM1-5_west_1981_2014.tif"
str_extract(x, "(?<=kc/)([^_]+_){2}[^_]+")
#匹配内容是:非下划线出现 1 次或多次(即 1 个单词)接 1 个下划线，
#上述部分重复 2 次， 再接一个非下划线出现 1 次或多次(即 1 个单词)，
#结果就是恰好匹配到第 3 个下划线出现之前

# 关于懒惰匹配
# 正则表达式通常都是贪婪匹配，即重复直到文本中能匹配的最长范围，例如匹配小括号:
str_extract("(1st) other (2nd)", "\\(.+\\)")
#若想只匹配到第 1 个右小括号，则需要懒惰匹配，在重复匹配后面加上“?”即可:
str_extract("(1st) other (2nd)", "\\(.+?\\)")

# 例1.3 分组捕获 
# 在正则表达式中可以用圆括号来分组，作用是:
# 确定优先规则;
# 组成一个整体;
# 拆分出整个匹配中的部分内容(称为捕获); 
# 捕获内容供后续引用或者替换。
# 比如，来自瓜子二手车的数据:若汽车型号是中文，则品牌与型号中间有空格;
# 若汽车型号为英文或数字，则品牌与型号中间没有空格。
# 若用正则表达式匹配“字母或数字”并分组，然后捕获该分组内容并添加空格以替换原内容，代码如下所示:
x = c("宝马X3 2016款", "大众 速腾2017款", "宝马3系2012款") 
str_replace(x, "([a-zA-Z0-9])", " \\1")
#后续操作就可以用空格拆分列(见 2.4.4 节)
#现有 6 位数字表示的时分秒数据，想用 lubridate::hms()解析成时间类型，但是在时分秒之间
#用冒号或空格分隔才能正确解析。下面分组捕获两组数字，并分别替换为该两位数字加冒号， 然后再解析成时间类型:
x = c("194631", "174223") #数值型也可以
x = str_replace_all(x, "(\\d{2})", " \\1:") 
x

# 更多分组的引用还有\\2、\\3 等。例如，纠正电影的年份和国别出现顺序不一致的情况， 
# 可以通过代码统一将信息转换成“国别_年份”，代码如下所示:
x = c("独行月球2022_Chinese","蜘蛛侠USA_2021","人生大事2022_Chinese") 
str_replace(x, "(\\d+)_(.+)","\\2_\\1")
#最后，再推荐一个来自 GitHub 的包 inferregex，该包可以推断正则表达式，
#用函数 infer_regex()可根据字符串推断正则表达式

## 1.6 控制结构 
#程序中的控制结构是指分支结构和循环结构
1.6.1 分支结构
正常程序结构与一步一步解决问题是一致的，即顺序结构， 过程中可能需要为不同情形选
不同的支路，即分支结构，还需 要用条件语句做判断以实现具体的分支
R 语言中条件语句的一般格式为: 
  
1.一个分支
if(条件) { 
  执行体
}

2.两个分支
if(条件) { 
  执行体 1
} else {
  执行体 2 
}

例如，计算 x ，代码如下:
if(x < 0) {
  y = -x
} else { 
  y=x
}

3.多个分支
if(条件1) { 
  执行体 1
} else if(条件2) {
  执行体2
} else {
  执行体 n 
}

# 多个分支的意思是，若满足“条件 1”，则执行“执行体 1”;
# 若满足“条件 2”，则执行“执 行体2”;
# 其他的情形，则执行“执行体n”。
# 若有需要，中间可以有任意多个else if块。
# 特别注意:分支的本意就是，不同分支之间不存在交叉(重叠)。 
# 另一种多分支的写法是用 switch():
x = "b"
v = switch(x, "a"="apple", "b"="banana", "c"="cherry")
v
#它的一个应用场景是:在自定义函数时，若需要根据参数的不同执行不同的代码块。
#关于自定义函数详见 1.7.1 节。
#例1.4 实现将百分制分数转化为五级制分数
if(score >= 90) {
  res = "优"
} else if(score >= 80) {
  res = "良"
} else if(score >= 70) {
  res = "中"
} else if(score >= 60) {
  res = "及格" } else {
    res = "不及格" }
#注意:若先写“score >=60”，结果就不对了。
#关于“条件”
# “条件”用逻辑表达式表示，必须返回一个逻辑值 TRUE 或 FALSE; 
#多个逻辑表达式，可以通过逻辑运算符组合以表示复杂条件;
#多个逻辑值的逻辑向量可以借助函数 any()和 all()得到一个逻辑值;
#函数 ifelse()可简化代码，仍以计算 x 为例:
#ifelse(x < 0, -x, x)

#1.6.2 循环结构
# 编程时可以减少代码重复的两个工具，一个是循环，另一个是函数
# 循环用来对多个同类输入做相同事情(即迭代)，例如对向量的每个元素做相同操作，
# 对数据框的不同列做相同操作，对不同的数据集做相同操作等
# R 语言循环迭代的三层境界如下所示
# 第一层:for 循环、while 循环、repeat 循环
# 第二层:apply 函数族
# 第三层:purrr 泛函式编程
# 关于跳出循环有以下两种方式
# 用关键字 next 跳出本次循环，进入下次循环
# 用关键词 break 跳出循环

# 实用场景
# 关于“for 循环运行速度慢”的说法，实际上已经过时了，现在的 R、MATLAB 等软件经过多
# 年的优化 已经不慢了，之所以表现出来慢，是因为你没有注意两个关键点:
# 提前为保存循环结果分配存储空间;
# 为循环体中涉及的数据选择合适的数据结构。
# apply 函数族和 purrr 泛函式编程能够更加高效简洁地实现一般的 for 循环和 while 循
# 环，但这并 不代表 for 循环、while 循环就没用了，它们可以在更高的层次使用(相对于
# 在逐元素级别使用)

# 1.for 循环 
# (1)基本的 for 循环
library(tidyverse)
df = as_tibble(iris[,1:4])

#用“复制-粘贴”法，计算前 4 列的均值:
mean(df[[1]])
mean(df[[2]])
mean(df[[3]])
mean(df[[4]])
#为了避免“粘贴-复制”操作多于两次，我们改用 for 循环实现:
output = vector("double", 4) #输出
for (i in 1:4) { #迭代器
  output[i] = mean(df[[i]]) #循环体
}
output

# for 循环有三个组件，即输出、迭代器、循环体
# 输出:output = vector("double", 4)
# 在循环开始之前，最好为输出结果分配足够的存储空间，这样效率更高。若每循环一次， 
# 就用 c()合并一次，效率会很低下。
# 通常是用 vector()函数创建一个给定长度的空向量，它有两个参数:向量类型(logical、 
# integer、double、character 等)、向量长度。
# 迭代器:i in 1:4
# 循环方式:每次 for 循环将为 i 赋一个 1~4 中的值，可将 i 理解为代词 it。 有时候会
# 用 1:length(df), 但更安全的做法是用 seq_along(df)，它能保证即使不小心遇到长度为 
# 0 的向量时，仍能正确工作。
# 循环体:output[i] = mean(df[[i]]) 即执行具体操作的代码，它将重复执行，每次对应不
# 同的 i 值。
# 第 1 次迭代将执行:output[1] = mean(df[[1]])
# 第 2 次迭代将执行:output[2] = mean(df[[2]])
# ......

# (2)for 循环的几种常用操作循环模式
# 循环模式
# 根据数值索引迭代:for(i in seq_along(xs)), 在迭代中使用 x[i]
# 根据元素值迭代:for(x in xs), 在迭代中使用 x
# 根据名字迭代:for(nm in names(xs)), 在迭代中使用 x[nm]
#若要创建命名向量并作为输出，可按如下方式命名结果向量:
results = vector("list", length(x))
names(results) = names(x)
#用数值索引迭代是最常用的形式，因为名字和元素都可以根据索引提取:
for (i in seq_along(x)) {
   name = names(x)[i]
   value = x[i]
}

# 将每次循环得到的结果合并为一个整体对象
# 这种情形在 for 循环中经常遇到。此时要尽量避免“每循环一次，就做一次拼接”，这样效
# 率很低。更好的做法是先将结果保存为列表，等循环结束再通过 unlist()或 
# purrr::flatten_dbl() 将列表转换成一个向量

# 先创建空列表，再将每次循环的结果依次存入列表:
output = list() # output = NULL也行 # 
#output = vector("list", 3)
for(i in 1:3) {
     output[[i]] = c(i, i^2)
}

# 另外两种类似的情形如下。
# 生成一个长字符串。不是用 str_c()函数将上一次的迭代结果拼接到一起，而是将结果保
# 存为字符向量，再用函数str_c(output, collapse= " ")合并为一个单独的字符串。
# 生成一个大的数据框。不是依次用 rbind()函数合并每次迭代的结果，而是将结果保存为列
# 表，再用 dplyr::bind_rows(output)函数合并成一个单独的数据框，或者直
# 接一步到位用 purrr::map_dfr()。 
# 所以，遇到上述模式时，要先转化为更复杂的结果对象，最后再做合并。

#2.while 循环 
#适用于迭代次数未知的情况
#while 循环更简单，因为它只包含两个组件:条件、循环体: 
while (condition) {
  循环体
}
# While 循环是比 for 循环更一般的循环，因为 for 循环总可以改写为 while 循环，但 
# while 循环不一定能改写为 for 循环:
for (i in seq_along(x)) {
 # 循环体 
}

# 等价于
i=1
while (i <= length(x)) {
 # 循环体
 i=i+1 
 }
#下面用 while 循环实现:反复随机生成标准正态分布随机数(关于生成随机数详见 1.7.2
#节)，若值大于 1 则停止:
set.seed(123) # 设置随机种子, 让结果可重现 
while(TRUE) {
  x = rnorm(1)
  print(x)
  if(x > 1) break
}
#while 循环并不常用，但在模拟时也较常用，特别是预先不知道迭代次数的情形。 

##3.repeat 循环
#重复执行循环体,直到满足退出条件
repeat{
  # 循环体
  if(退出条件) break
}

#注意，repeat 循环至少会执行一次。 repeat 循环等价于:
while (TRUE) {
  # 循环体
  if(退出条件) break
}
  
#例如，用如下泰勒公式近似计算 e :
s = 1.0
x=1 
k=0
repeat{ 
  k=k+1 
  x=x/k
  s=s+x
  if(x < 1e-10) break
}
stringr::str_glue("迭代 {k} 次, 得到e = {s}") 

#4.apply 函数族
#建议弃用 apply 函数族，直接用 purrr::map 系列。 
#(1)apply()函数
# apply()函数是最常用的可以代替 for 循环的函数，可以对矩阵、数据框、多维数组，按
# 行或列或页进行循环计算，即将逐行或逐列或逐页的元素分别传递给函数 FUN 进行迭代
# 计算。其基本格式为:
# apply(x, MARGIN, FUN, ...)
# x:为数据对象(矩阵、多维数组、数据框)
# MARGIN:1 表示按行，2 表示按列，3 表示按页
# FUN:表示要作用的函数
x = matrix(1:6, ncol = 3)
x
apply(x, 1, mean)
apply(x, 2, mean)
#(2)tapply()函数 该函数可以按照因子分组，实现逐分组迭代: 
height = c(165, 170, 168, 172, 159)
sex = factor(c("男", "女", "男", "男", "女")) 
tapply(height, sex, mean)
#注意，height 与 sex 是等长的向量，对应元素分别为同一人的身高和性别，tapply() 函
#数分男女两组计算了身高平均值。
#(3)lapply()函数
#lapply()函数是一个最基础的循环操作函数，用来对 vector、list、data.frame 逐元、
#逐成分、 逐列分别应用函数 FUN，并返回和 x 长度相同的 list 对象。其基本格式为:
# lapply(x, FUN, ...) 
# x:为数据对象(列表、数据框、向量)
# FUN:表示要作用的函数
# 按行求均值
# 按列求均值
lapply(df, mean) # 对前文df计算各列的均值 
#(4)sapply()函数
#sapply()函数是 lapply()的简化版本，只是多了一个参数 simplify，若 simplify=FALSE，
#则与 lapply()相同;若 simply = TRUE，则将输出的 list 简化为向量或矩阵。其基本格式
#为:sapply(x, FUN, simplify = TRUE, ...)
sapply(df, mean) # 对前文df计算各列的均值


#5.purrr 泛函式循环迭代
#相对于 apply 族，purrr 泛函式循环迭代提供了更多的一致性、规范性和便利性，更容易 
#记住和使用。
#(1)几个基本概念
# 循环迭代
# 循环迭代就是将函数依次应用(映射)到序列的每一个元素上，做相同的操作。而序列是由一
# 系列可以根据位置索引的元素构成，元素可以很复杂，也可以是不同类型的。原子
# 向量和列表都是序列。
# 泛函式编程
# 泛函其实就是函数的函数，在编程中表示把函数作用在函数上，或者说函数包含其他函数作
# 为参数。
# 循环迭代本质上就是将一个函数依次应用(映射)到序列的每一个元素上，用泛函式表示 
# 即map(x, f)。
# purrr 泛函式编程解决循环迭代问题的逻辑是:针对序列中每个单独的元素，怎么处理它能
# 得到正确的结果，将这个过程定义为函数，再 map(映射)到序列中的每一个元素，将得到的
# 多个结果(每个元素作用后返回一个结果)，再打包到一起返回，并且可以根据想要的结果类 
# 型选用对应的 map 后缀。
# 对循环迭代返回类型的控制
# map 系列函数都有后缀形式，以决定循环迭代之后返回的数据类型，这是 purrr 比 apply 
# 函数族更先进和便利的一大优势。常用后缀如下。
# map_chr(.x,.f):返回字符型向量。
# map_lgl(.x,.f):返回逻辑型向量。
# map_dbl(.x,.f):返回实数型向量。
# map_int(.x,.f):返回整数型向量。
# map_dfr(.x,.f):返回数据框列表，再通过 bind_rows 按行合并为一个数据框。
# map_dfc(.x,.f):返回数据框列表，再通过 bind_cols 按列合并为一个数据框。
# 将序列(要操作的数据)作为第一个参数 x，是为了便于使用管道。 

# purrr 风格的公式
# 在序列上进行循环迭代(应用函数)，经常需要自定义函数，但有些简单的函数如果也用 
# function 定义，未免显得麻烦和啰嗦。purrr 包提供了对 purrr 风格的公式(匿名函数)的 
# 支持，解决了这一问题。如果读者熟悉其他语言的匿名函数，很自然地就能习惯 purrr 风
# 格的公式。
# 前面提到，purrr包实现迭代循环是用map(x, f)，其中f是要应用的函数，想用匿名函数来
# 写它，它要应用在序列 x 上，就是要和序列 x 相关联，那么就限定用序列参数名关联好了
# ，即将该序列参数名作为匿名函数的参数使用:
# 一元函数:序列参数是.x，比如f(x)=x^2+1,其purrr风格的公式就写为:~ .x ^ 2 + 1
# 二元函数:序列参数是.x或.y，比如f(x,y)=x^2+3y,其purrr风格的公式就写为:
# ~ .x ^ 2 - 3 * .y
# 多元函数:序列参数是 ..1,..2,..3等，比如f(x,y,z)=ln(x+y+z), 其purrr风格
# 的公式就写为:~ log(..1 + ..2 + ..3) 所有序列参数可以用“...”代替，比如，sum(...)
# 同sum(..1, ..2, ..3)。

#(2)map():依次应用一元函数到一个序列的每个元素 
#map(.x, .f, ...)
#map_*(.x, .f, ...)
#.x 为序列
#.f 为要应用的一元函数，或 purrr 风格公式(匿名函数)。
#... 可用于设置函数.f 的其他参数。
# map()返回结果列表，基本同 lapply()
# 例如，计算前文 df，每列的均值，即依次将 mean()函数应用到第 1 列、第 2 列......
# 并控制返回结果为 double 向量:
map(df, mean)

#说明:df 是数据框(特殊的列表)，作为序列其元素依次是:df[[1]], df[[2]]......所 以，
#map(df, mean)相当于依次计算:mean(df[[1]]),mean(df[[2]])......返回结果是 double 
#型数值，更好的做法是，控制返回类型为数值向量，只需使用以下方法: 
map_dbl(df, mean)

#另外，mean()函数还有其他参数(如 na.rm)，若上述计算过程需要设置忽略缺失值，
#只需使用以下方法:
map_dbl(df, mean, na.rm = TRUE) # 数据不含 NA, 故结果同上(略) 
map_dbl(df, ~mean(.x, na.rm = TRUE)) # purrr风格公式写法

#有了 map()函数，对于自定义只接受标量的一元函数，比如 f(x), 想要让它支持将向量作
#为输入，根本 不需要改造原函数，只需按以下方式操作:
map_*(xs, f) # xs表示若干个x构成的序列 

#(3)map2():依次应用二元函数到两个序列的每对元素
# map2(.x, .y .f, ...)
# map2_*(.x, .y, .f, ...)
# .x 为序列 1。
# .y 为序列 2。
# .f 为要应用的二元函数或 purrr 风格公式(匿名函数)
# ...可用于设置函数.f 的其他参数

#例如，根据身高、体重数据计算 BMI 指数:
height = c(1.58, 1.76, 1.64)
weight = c(52, 73, 68)
cal_BMI = function(h, w) w / h ^ 2 # 定义计算BMI的函数
map2_dbl(height, weight, cal_BMI)

#说明:序列 1 的元素为 height[[1]], height[[2]]......
#序列 2 的元素为 weight[[1]], weight[[2]]...... 
#因此，map2_dbl(height, weight, cal_BMI)相当于依次计算: 
#cal_BMI(height[[1]], weight[[1]]), cal_BMI(height[[2]], weight[[2]]), ......
#更简洁的 purrr 风格公式写法(此处省略了自定义函数)如下: 
map2_dbl(height, weight, ~ .y / .x^2)
#同样，有了 map2()函数，对于自定义只接受标量的二元函数，
#比如 f(x, y), 想要让它支持将向量作 为输入，根本不需要改造原函数，
#只需按以下方式操作:
map2_*(xs, ys, f) # xs, ys分别表示若干个x, y构成的序列

#(4)pmap():应用多元函数到多个序列的每组元素，可以实现对数据框逐行迭代
#因为 pmap()函数是在多个长度相同的列表上进行迭代，而长度相同的列表就是数据框，
#所以，pmap()的多元迭代就是依次在数据框的每一行上进行迭代! 
weight = c(52, 73, 68)
cal_BMI = function(h, w) w / h ^ 2 
# 定义计算BMI的函数 
map2_dbl(height, weight, cal_BMI)
    
# pmap(.l, .f, ...)
# pmap_*(.l, .f, ...)
# .l 为数据框，
# .f 为要应用的多元函数 ...可设置函数.f 的其他参数
# 注意:“.f”是几元函数，对应的数据框 “.l”就有几列，“.f”将依次在数据框“.l”
# 的每一行上进行迭代

#例如，分别生成不同数量不同均值和标准差的正态分布随机数，代码如下
df = tibble(
  n = c(1, 3, 5),
  mean = c(5, 10, -3),
  sd = c(1, 5, 10))
df

set.seed(123)
pmap(df, rnorm)

#说明:这里的 rnorm(n, mean, sd)是三元函数，
# pmap(df, rnorm)相当于将三元函数 rnorm()依次应用到数据框 df 的每一行上，
#即依次执行以下代码:
rnorm(1, 5, 1),
rnorm(3, 10, 5),
rnorm(5, -3, 10)
# 注意，这里 df 中的列名，必须与 rnorm()函数的参数名相同(列序随便)。
# 若要避免这种局限，可以使用 purrr 风格的公式写法:
#pmap_*()提供了一种行化操作数据框的办法
pmap_dbl(df, ~ mean(c(...))) # 按行求均值
pmap_chr(df, str_c, sep = "-") # 将各行拼接在一起
pmap(df, ~ rnorm(..1, ..2, ..3)) # 或者简写为 pmap(df, ~ rnorm(...))

#其他 purrr 函数
#imap_*(.x, .f):带索引的 map_*()系列在迭代的时候既迭代元素，
#又迭代元素的索引(位置或名字)，purrr 风格公式中用 .y 表示索引。
#invoke_map_*(.f, .x, ...):将多个函数依次应用到序列，相当于依次执行:
#.f[[1]](.x,...),.f[[2]](.x, ...)......
#walk 系列:walk(.l, .f, ...), walk2(.l, .f, ...), pwalk(.l, .f, ...)
#将函数依次作用到序列上，不返回结果。有些批量操作是没有或不关心返回结果的，
#例如批量保存 数据到文件、批量绘图保存到文件等。
#modify 系列:modify(.x, .f, ...), modify2(.x, .y, .f, ...), 
#modify_ depth(.x, .depth, .f, ...)
#将函数“.f”依次作用到序列“.x”，并返回修改后的序列“.x”
#reduce():可先对序列前两个元素应用函数，再对结果与第 3 个元素应用函数，
#再对结果与第 4 个元素应用函数......直到所有的元都被“reduced”。
#reduce(1:100, sum)是对 1~100 求累加和。  reduce()可用于批量数据连接。
#accumulate():与 reduce()作用方式相同，不同之处是 reduce()只返回最终的结果，
#而 accumulate()会返回所有中间结果。


##1.7 自定义函数
# 编程中的函数是用来实现某个功能，其一般形式为:
# (返回值1，..., 返回值m) = 函数名(输入1, ..., 输入n) 你只要把输入给它，它就能在
# 内部进行相应处理，把你想要的返回值给你。 
# 这些输入和返回值，在函数定义时，都要有固定的类型(模具)限制，叫作形参(形
# 式上的参数);在函数调用时，必须给它对应类型的具体数值，才能真正地去做处理，这叫 
# 作实参(实际的参数)。定义函数就好比创造一个模具，调用函数就好比用模具批量生成产品。
# 使用函数最大的好处，就是将实现的某个功能封装成模具，从而可以反复使用。这就避免了
# 写大量重复的代码，程序的可读性也大大加强。
# 以前文的将百分制分数转化为五级制分数为例，如果有一个百分制分数，就这样转化一次， 
# 那么如果有 10 个学生分数，就得写 100 多行代码。因此有必要封装成一个函数。

# 1.7.1 自定义函数 
# 1.自定义函数的一般语法
# 在 R 中，自定义函数的一般格式为:
# 函数名 = function(输入1, ..., 输入n) { 
#   函数体
# return(返回值)
# }

# 1.7 自定义函数
# 注意，return 并不是必需的，默认将函数体最后一行的值作为返回值，
# 也就是说“return(返回值)” 完全可以换成“返回值”
# 2.自定义一个函数
# 我们想要自定义一个函数，能够实现把百分制分数转化为五级制分数的功能
# 基于前面对函数的理解，我们按以下步骤进行
# 
# 第一步，分析输入和输出，设计函数外形
# 输入有几个，分别是什么，适合用什么数据结构存放。 
# 输出有几个，分别是什么，适合用什么数据结构存放。
# 对于本问题，输入有 1 个，百分制分数，适合采用数值型存放;
# 输出有 1 个，五级制分数， 适合采用字符串存放。
# 然后就可以设计自定义函数的外形，如下所示: 
#   Score_Conv = function(score) {
#     # 实现将一个百分制分数转化为五级分数
#     # 输入参数: score为数值型, 百分制分数 
#     # 返回值: res为字符串型, 五级分数 
#     #  ...
#   }
# 
# 函数名和变量可以随便起名，但是建议使用有具体含义的单词。
# 另外，为函数增加注释是一个好习惯。这 些都是为了代码的可读性。
# 
# 第二步，梳理功能的实现过程。
# 前言中在谈到“如何自己写代码”时讲到:“分解问题 + 实例梳理 + ‘翻译’及调试”， 
# 完全适用于这里，不再赘述。
# 拿一组本例中(只有一个)具体的形参的值作为输入，比如 76 分，分析怎么得到对应的
# 五级分数“良”。这依赖于对五级分数界限的选取，选定之后做分支判断即可实现，即像
# 前文的条件语句中的示例那样。
# 复杂的功能就需要更耐心地梳理和思考甚至借助一些算法，当然也离不开对代码片段的
# 调试
# score = 76
# # 实现将一个百分制分数转化为五级分数
# # 输入参数: score为数值型, 百分制分数 # 返回值: res为字符串型, 五级分数 ...
# }
#    if(score >= 90) { res = "优"
# } else if(score >= 80) { res = "良"
# } else if(score >= 70) { res = "中"
# } else if(score >= 60) { res = "及格"
# } else {
# res = "不及格"
# } res
# 
# 拿一组具体的形参值作为输入，通过逐步调试可以得到正确的返回值结果，
# 这一步骤非常 关键和有必要。
# 第三步，将第二步的代码封装到函数体。
# 基本就是原样作为函数体放入函数，原来的变量赋值语句不需要了，只需要形参。
# 具体代 码如下所示:
# Score_Conv = function(score) {
# if(score >= 90) {
# res = "优"
# } else if(score >= 80) {
# res = "良"
# } else if(score >= 70) {
# res = "中"
# } else if(score >= 60) { res = "及格"
# } else {
# res = "不及格" }
# res }

# 3.调用函数 
# 要调用自定义函数，必须要先加载到当前变量窗口(内存)，有两种方法:
# 需要选中并执行函数代码;
# 将函数保存为同名的 Score_Conv.R 文件，然后执行 source("Score_Conv.R")。
# 之后就可以调用函数了，给它一个实参 76，输出结果为“中”: 
# Score_Conv(76)
# 关于向函数传递参数
# 要调用一个函数，比如 f(x, y)，首先要清楚其形参 x 和 y 所要求的类型，假设 x 要求是
# 数值向量，y 要求是单个逻辑值。
# 那么，要调用该函数，首先需要准备与形参类型相符的实参(同名异名均可)，比如
# a = c(3.56, 2.1)
# b = FALSE
# 再调用函数:
# f(a, b) # 同直接给值: f(c(3.56,2.1), FALSE)
# 调用函数时若不指定参数名，则默认是根据位置关联形参，
# 即以x = a, y = b的方式进入函数体。
# 调用函数时若指定参数名，则根据参数名关联形参，位置不再重要，比如:
# f(y = b, x = a) # 效果同上

# 4.向量化改进
# 我们希望自定义函数也能处理向量输入，即输入多个百分制分数，能一下都转化为五级分数。
# 这也是所谓的“向量化编程”思维，就是要习惯用向量(矩阵)去思考、去表达。
# 
# 方法一:修改自定义函数
# 将输入参数设计为数值向量，函数体也要相应地修改，借助循环依次处理向量中的每个元素，
# 就相当于再套一层 for 循环
Score_Conv2 = function(score) {
  n = length(score)
  res = vector("character", n)
  for(i in 1:n) {
    if(score[i] >= 90) { 
      res[i] = "优"
    } else if(score[i] >= 80) { 
      res[i] = "良"
    } else if(score[i] >= 70) { 
      res[i] = "中"
    } else if(score[i] >= 60) {
      res[i] = "及格"
    } else {
      res[i] = "不及格"
    } }
  res }
# 测试函数
scores = c(35, 67, 100) 
Score_Conv2(scores)

# 方法二:借助 apply 族或 map 系列函数
# 简单的循环语句基本都可以改用 apply 族或 map 系列函数实现，其作用相当于依次“应用” 
# 某函数到序列的每个元素上。
# 也就是说，不需要修改原函数，直接就能实现向量化操作:
scores = c(35, 67, 100)
map_chr(scores, Score_Conv)

# 5.处理多个返回值
# 若自定义函数需要有多个返回值，R 的处理方法是，将多个返回值放入一个
# 列表(或数据 框)，再返回一个列表。
# 例如，用自定义函数计算一个数值向量的均值和标准差:
MeanStd = function(x) {
  mu = mean(x)
  std  = sqrt(sum((x-mu)^2) / (length(x)-1))
  list(mu=mu, std=std)
}
# 测试函数
x = c(2, 6, 4, 9, 12)
MeanStd(x)

#6.默认参数值
#有时候需要为输入参数设置默认值。以前面的计算数值向量的均值和标准差的函数为例
#我们知道，标准差的计算公式有两种形式，一种是总体标准差除以 n，另一种是样本标准
#差除以 n − 1。 此时，没有必要写两个版本的函数，只需要再增加一个指示参数，将使
#用较多的版本设为默认即可
MeanStd2 = function(x, type = 1) {
  mu = mean(x)
  n = length(x)
  if(type == 1) {
    std =sqrt(sum((x-mu)^2)/(n-1))
  } else {
    std  = sqrt(sum((x - mu) ^ 2) / n)
  }
  list(mu = mu, std = std)
}

# 测试函数
x = c(2, 6, 4, 9, 12)
# MeanStd2(x) # 同MeanStd(x) 
MeanStd2(x, 2)

#用 type = 1 来指示表意并不明确，可以用表意更明确的字符串来指示，这就需要用到 
#switch()，让不同的指示值等于相应的代码块，因为代码块往往是多行，需要用大括号
#括起来， 注意分支与分支之间的逗号不能少

MeanStd3 = function(x, type = "sample") {
  mu = mean(x)
  n = length(x)
  switch(type,
         "sample" = {
           std = sqrt(sum((x - mu) ^ 2) / (n - 1))
         },
         "population" = {
           std = sqrt(sum((x - mu) ^ 2) / n)
         })
  list(mu = mu, std = std)
}
MeanStd3(x)

MeanStd3(x, "population")


#7.“...”参数 
#一般函数参数只接受一个对象，即使不指定参数名，也会按位置对应参数。例如: 
my_sum = function(x, y) {
  sum(x, y) }
my_sum(1, 2)
#但是，如果想对3个数求和，怎么办?直接用my_sum(1, 2, 3)会报错。“...”是一个特殊参
#数，可以接受任意多个对象，并作为一个列表传递它们: 
dots_sum = function(...) {
  sum(...) 
  }
dots_sum(1)
dots_sum(1, 2, 3, 4, 5)


# 来自 Base R 的函数:可直接使用
# 来自各种扩展包的函数:需载入包，或加上包名前缀:“包名::函数名()”
# 这些函数的使用，可以通过“?函数名”查阅其帮助，以及查阅包页面的Reference manual 
# 和 Vignettes(若有)
# 下面对常用的 R 自带的函数做分类总结

#1.基本数学函数
round(x, digits)#IEEE 754标准的四舍五入, 保留n位小数 # 四舍五入, 保留n位有效数字
signif(x, digits)# 四舍五入, 保留n位有效数字
ceiling(x)# 向上取整, 例如ceiling(pi)为4
floor(x)# 向下取整, 例如floor(pi)为3
sign(x)# 符号函数
abs(x)# 取绝对值
sqrt(x)# 求平方根
exp(x)# e的x次幂
log(x, base)# 对x取以......为底的对数, 默认以e为底 
log2(x)# 对x取以2为底的对数
log10(x)# 对x取以10为底的对数 
Re(z)# 返回复数 z 的实部
Im(z)# 返回复数 z 的虚部
Mod(z)# 求复数z的模
Arg(z)# 求复数 z 的辐角
Conj(z)# 求复数z的共轭复数

2.三角函数与双曲函数
sin(x) # 正弦函数 
cos(x) # 余弦函数 
tan(x) # 正切函数 
asin(x) # 反正弦函数 
acos(x) # 反余弦函数 
atan(x) # 反正切函数 
sinh(x) # 双曲正弦函数 
cosh(x) # 双曲余弦函数 
tanh(x) # 双曲正切函数 
asinh(x) # 反双曲正弦函数 
acosh(x) # 反双曲余弦函数 
atanh(x) # 反双曲正切函数

3.矩阵函数
nrow(A) # 返回矩阵 A 的行数
ncol(A) # 返回矩阵 A 的列数
dim(A) # 返回矩阵 x 的维数 (几行×几列)
colSums(A) # 对矩阵A的各列求和
rowSums(A) # 对矩阵A的各行求和
colMeans(A) # 对矩阵A的各列求均值
rowMeans(A) # 对矩阵A的各行求均值
t(A) # 对矩阵A转置
det(A) # 计算方阵A的行列式
crossprod(A, B) # 计算矩阵A与B的内积, t(A) %*% B
outer(A, B) # 计算矩阵的外积 (叉积)， A %o% B
diag(x) # 取矩阵对角线元素，或根据向量生成对角矩阵
diag(n) # 生成n阶单位矩阵
solve(A) # 求逆矩阵 (要求矩阵可逆)
solve(A, B) # 解线性方程组AX=B
ginv(A) # 求矩阵A的广义逆(Moore-Penrose逆), MASS包
eigen() # 返回矩阵的特征值与特征向量(列)
kronecker(A, B) # 计算矩阵A与B的Kronecker积
svd(A) # 对矩阵A做奇异值分解，A=UDV'
qr(A) # 对矩阵A做QR分解: A=QR, Q为酉矩阵, R为阶梯形矩阵
chol(A) # 对正定矩阵A做Choleski分解, A=P'P，P为上三角矩阵
A[upper.tri(A)] # 提取矩阵A的上三角矩阵
A[lower.tri(A)] # 提取矩阵A的下三角矩阵

4概率函数
factorial(n) # 计算n的阶乘 
choose(n, k) # 计算组合数
gamma(x) # Gamma函数 
beta(a, b) # beta函数
combn(x, m) # 生成x中任取m个元的所有组合, x为向量或整数n

#例如:
combn(4, 2)
combn(c("甲","乙","丙","丁"), 2)
factorial(n)
choose(n, k)
gamma(x)
beta(a, b)
combn(x, m)

#在 R 中，常用的概率函数有密度函数、分布函数、分位数函数、生成随机数函数，
#其写法为:
# d = 密度函数(density)
# p = 分布函数(distribution)
# q = 分位数函数(quantile)
# r = 生成随机数(random)
# 上述“4 个字母 + 分布的缩写”，就构成通常的概率函数
dnorm(3, 0, 2) # 正态分布N(0, 4) 在3处的密度值
pnorm(1:3, 1, 2) # N(1,4)分布在1,2,3处的分布函数值
# 命中率为0.02, 独立射击400次, 至少击中两次的概率 
1 - sum(dbinom(0:1, 400, 0.02))

pnorm(2, 1, 2) - pnorm(0, 1, 2)
qnorm(1-0.025,0,1)

set.seed(123) # 设置随机种子, 以重现随机结果 
rnorm(5, 0, 1) # 生成5个服从N(0,1)分布的随机数

# 随机抽样: 
# sample()函数，用来从向量中重复或非重复地随机抽样，基本格式为:
# sample(x, size, replace = FALSE, prob)
# x:向量或整数
# size:设置抽样次数
# replace:设置是否重复抽样
# prob:设定抽样权重
set.seed(2020)
sample(c("正","反"), 10, replace=TRUE)

#5.统计函数
min(x) # 求最小值 
cummin(x) # 求累计最小值
max(x) # 求最大值
cummax(x) # 求累计最大值
range(x) # 求x的范围:[最小值，最大值] (向量) 
sum(x) # 求和
cumsum(x) # 求累计和
prod(x) # 求积
cumprod(x) # 求累计积
mean(x) # 求平均值
median(x) # 求中位数
quantile(x, pr) # 求分位数, x为数值向量, pr为概率值
sd(x) # 求标准差
var(x) # 求方差
cov(x) # 求协方差
cor(x) # 求相关系数
scale(x, center=TRUE, scale=FALSE) # 对数据做中心化: 减去均值
scale(x, center=TRUE, scale=TRUE) # 对数据做标准化

#自定义归一化函数:
rescale = function(x, type=1) {
# type=1正向指标, type=2负向指标 
  rng = range(x, na.rm = TRUE) 
  if (type == 1) {
    (x - rng[1]) / (rng[2] - rng[1])
  } else {
    (rng[2] - x) / (rng[2] - rng[1])
    }
}

x = c(1, 2, 3, NA, 5)
rescale(x)

# 6.时间序列函数 
# lag()函数，用来计算时间序列的滞后，基本格式为:
# lag(x, k, ...) 
# x:为数值向量/矩阵或一元/多元时间序列;
# k:为滞后阶数，默认为 1。

# diff()函数，用来计算时间序列的差分，基本格式为:
# diff(x, lag = 1, difference = 1, ...)
# x:为数值向量/矩阵; 
# lag:为滞后阶数，默认为 1; 
# difference:为差分阶数，默认为 1。
#Yt 的 j 阶滞后为 Yt - j :
  
x = ts(1:8, frequency = 4, start = 2015)
x
stats::lag(x, 4) # 避免被dplyr::lag()覆盖 

#Yt的一阶差分为Yt Yt Yt1，二阶差分为2Yt Yt Yt1...... 
x = c(1, 3, 6, 8, 10)
x
diff(x, differences = 1)
diff(x, differences = 2)
diff(x, lag = 2, differences = 1)

#7.其它函数
unique(x, ...) # 返回唯一值, 即去掉重复元素或观测
duplicated(x, ...) # 判断元素或观测是否重复(多余), 返回逻辑值向量
anyDuplicated(x, ...) # 返回重复元素或观测的索引
rle(x) # 统计向量中连续相同值的长度
inverse.rle(x) # rle()的反向版本, x为list(lengths, values)
dput(x, file)  # 方便创建最小可重现案例用于向他人提问
get()/mget() # 根据名字获取一个或多个当前对象的值

# 文件操作函数 
list.files(path,pattern, ...) # 列出某路径下的匹配的文件路径
file.create(...)
file.exists(...) 
file.remove(...)
file.rename(from, to) 
file.append(file1, file2) 
file.copy(from, to, overwrite, ...)

# 拓展学习
# 读者如果想进一步了解 R 语言的基本语法，建议大家阅读 Hadley 编写的《R 数据科学》
# (R for Data Science)、Advanced R，任坤编写的《R 语言编程指南》，
# 李东风编写的《R 语言教程》。 
# 读者如果想进一步了解 R 语言与时间序列，建议大家阅读 Hyndman 编写的 Forecasting: 
# Principles and Practice, 3rd Edition。
# 读者如果想进一步了解因子、字符串、日期时间、泛函式循环迭代，建议大家了解 
# forcats 包、stringr 包、 lubridate 包、purrr 包文档及相关资源。