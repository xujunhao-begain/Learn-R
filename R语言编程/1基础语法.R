# 1 基础语法
## 1.1 搭建 R 环境及常用操作
### 1.1.1 搭建R环境
### 1.1.2 常用操作
# 安装包
install.packages("openxlsx")
devtools::install_github("tidyverse/dplyr") 
remotes::install_github("tidyverse/dplyr")

# 加载包 
library(openxlsx)

# 更新包 
update.packages("openxlsx") 
update.packages() #更新所有包

# 删除包
remove.packages("openxlsx")

# 获取或设置当前路径 getwd()
setwd("D:/R-4.2.2/tests")

# 赋值
x <- 1:10
x+2

# 基本运算
# 数学运算
# + - * /、^(求幂)、%%(按模求余1)、%/%(整除)。
# 比较运算
# >、<、>=、<=、==、!=;
# identical(x,y)— 判断两个对象是否严格相等;
# all.equal(x,y)或 dplyr::near(x,y)— 判断两个浮点数是否近似相等 (误差为 1.5e−8)。
# 逻辑运算
## | (或)、 & (与)、! (非)、xor()(异或)

# 基本数据类型
# R 的基本数据类型
# numeric— 数值型，又分为integer(整数型)和double(浮点型); 
# logical— 逻辑型，只有TRUE和FALSE，或T和F;
# character— 字符型，引号1括起来的若干字符。
# R 中用 NA 表示缺失值，NULL 表示空值，NaN 表示非数，Inf 表示无穷大。
# 对于 R 中的大多数函数，NA 具有“传染性”，即 NA 参与的运算，结果会变成 NA。R 自
# 带的很多函数都提供 na.rm 参数设置，以便于设定计算时是否忽略缺失值。 
# 特别要注意:判断 x 是否为 NA，不是用 x==NA，而是用 is.na(x)。
# 可用函数 class(x) / typeof(x) / mode(x)查看对象 x 的类型。
# 在展现数据的细节方面，mode()性能最弱，class()性能一般，typeof()性 能最强。
# str(x)可以显示对象x的结构

# 保存和载入数据
save(x, file = "data/dat.Rda")
load("data/dat.Rda")

# 清屏和清除内存变量
# 按“Ctrl + L”组合键或单击命令窗口右上角的“小刷子”图标可对命令窗口清屏。 
# 若要清除当前变量，使用以下命令:
rm(x) # 清除变量x 
rm(list = ls(all = TRUE)) # 清除所有当前变量


## 1.2 数据结构:向量、矩阵、多维数组
# 数据结构是为了便于存储不同类型的数据而设计的数据容器。
# 学习数据结构，就是要把各 个数据容器的特点、适合存取什么样的数据理解透彻

### 1.2.1 向量(一维数据)
# 常用的向量有数值向量、逻辑向量、字符向量
# 1.数值向量
# 数值向量就是由数值组成的向量，单个数值是长度为 1 的数值向量，例如:
x = 1.5

#我们可以用 numeric()创建一个全为 0 的指定长度的数值向量，如下所示:
numeric(10)

#在 R 中经常用函数 c()将多个对象合并到一起: 
c(1, 2, 3, 4, 5)
c(1, 2, c(3, 4, 5)) # 将多个数值向量合并成一个数值向量 

#创建等差的数值向量，用:或者函数 seq()，基本格式为: 
seq(from, to, by, length.out, along.with, ...)
# from:设置首项(默认为 1)
# to:设置尾项
# by:设置等差值(默认为 1 或 −1)
# length.out:设置序列长度
# along.with:以该参数的长度作为序列长度
1:5 # 同seq(5)或seq(1,5)
seq(1, 10, 2) # 从1开始, 到10结束, 步长为2
seq(3, length.out=10)

# 创建重复的数值向量用函数 rep()，基本格式为: 
# rep(x, times,length.out, each, ...)
# x:为要重复的序列
# times:设置序列的重复次数
# length.out:设置所产生的序列的长度
# each:设置每个元素分别重复的次数(默认为 1)
x = 1:3
rep(x, 2)
rep(x, each = 2)
rep(x, c(2, 1, 2))
rep(x, each = 2, length.out = 4)
rep(x, times = 3, each = 2)

# 向量可以做“+、−、*、/”四则运算，即对应元素分别做运算的向量化运算
# 注意，将 R中两个不同长度的向量做运算，短的会自动循环补齐以配合长的
2:3 + 1:5

# 2.逻辑向量
# 逻辑向量是由逻辑值(TRUE 或 FALSE，或简写为 T 或 F)组成的向量。
# 对向量做逻辑运算，得到的结果是逻辑向量:
c(1, 2) > c(2, 1) # 等价于c(1 > 2, 2 > 1)
c(2,3)>c(1,2,-1,3) #等价于c(2>1,3>2,2>-1,3>3) 

# 除了比较运算符外，还可以用 %in% 判断元素是否属于集合:
c(1, 4) %in% c(1, 2, 3) # 左边向量每一个元素是否属于右边集合

# 在构造筛选行的条件时，经常有人用错语法，请参考以下规则
# %in% 表示属于，用于判断(左边)元素是否属于(右边)集合
# == 表示等于，用于判断(左边)元素是否等于(右边)元素

# 3.字符向量
# 字符(串)向量，是由一组字符串组成的向量，在 R 中单引号和双引号都可以用来生成字 符向量。
"hello, world!"
c("Hello", "World")
c("Hello", "World") == "Hello, World"

#要想字符串中出现单引号或双引号，可以将单双引号错开，
#或者用转义字符“\”来做转义， 用 writeLines()函数输出纯字符串内容，如下所示:
'Is "You" a Chinese name?'
writeLines("Is \"You\" a Chinese name?")

#4.访问向量子集
# 访问向量子集即访问向量的一些特定元素或者某个子集
# 注意，R 中的索引是从 1 开始的
# 使用元素的位置来访问，形式如下所示:
v1 = c(1, 2, 3, 4)
#也可以访问任意位置的数值向量，但是注意索引不能既有正数又有负数:
v1[2] # 第2个元素
v1[2:4] # 第2~4个元素
v1[-3] # 除了第3个之外的元素
v1[c(1,3)]
v1[c(1, 2, -3)] # 报错 访问不存在的位置也是可以的，此时返回 NA:
v1[3:6]

#使用逻辑向量来访问，输入与向量相同长度的逻辑向量，以此决定每一个元素是否要被获取:
v1[c(TRUE, FALSE, TRUE, FALSE)] 

#这可以引申为“根据条件访问向量子集”:
v1[v1 <= 2] # 同v1[which(v1 <= 2)]或subset(v1, v1<=2) v1[v1 ^ 2 - v1 >= 2]
which.max(v1) # 返回向量v1中最大值所在的位置
which.min(v1) # 返回向量v1中最小值所在的位置


#5.为向量子集赋值，替换相应元素
#为向量子集赋值，就是先访问到向量子集，再赋值
v1[2:4] = c(0, 1, 3)
v1[c(TRUE, FALSE, TRUE, FALSE)] = c(3, 2)
v1[v1 <= 2] = 0
x[c("a", "a", "c")] # 重复访问也是可以的 x["d"] # 访问不存在的名字
v1[2] = 0
#注意，若对不存在的位置赋值，前面将用 NA 补齐: 
v1[10] = 8
v1

#6.为向量元素命名 
#你可以在创建向量的同时对其每个元素命名，代码如下:
x = c(a = 1, b = 2, c = 3)
x

#命名后，就可以通过名字来访问向量元素，代码如下:
x[c("a", "c")]
#获取向量元素的名字，代码如下:
names(x)

#更改向量元素的名字，代码如下:
names(x) = c("x", "y", "z")
x["z"]

#移除向量元素的名字，代码如下:
names(x) = NULL
x

# [] 与[[]] 的区别
# [ ]可以提取对象的子集，[[ ]]可以提取对象内的元素。 二者的区别:以向量为例，可以将一个向量比作 10 盒糖果，你可以使用[ ]获取其中的 3 盒糖果，使用 [[ ]]打开盒子并从中取出一颗糖果。
# 对于未对元素命名的向量，使用[ ]和[[ ]]取出一个元素会产生相同的结果。但对于已对元素命名的 向量，二者会产生不同的结果，如下所示:
#   x = c(a = 1, b = 2, c = 3)
# x["a"] # 取出标签为"a"的糖果盒
# ## a ## 1
# x[["a"]] # 取出标签为"a"的糖果盒里的糖果
# ## [1] 1
# 由于[[ ]]只能用于提取出一个元素，不适用于提取多个元素的情况，因此[[ ]]不能用于负整数，负 整数意味着提取除特定位置之外的所有元素。 使用含有不存在的位置或名称来创建向量子集时将会产生缺失值。但当使用[[ ]]提取一个位置超出范 围或者对应名称不存在的元素时，该命令将会无法运行并产生错误信息。 例如，以下三个语句会报错:
#   x[[c(1, 2)]]
# x[[-1]]
# x[["d"]]

# 7.对向量排序
#向量排序函数 sort()，基本格式为:
# sort(x, decreasing, na.last, ...)
# x:为排序对象(数值型或字符型)
# decreasing:默认为 FALSE 即升序，TRUE 为降序
# na.last:默认为 FALSE，若为 TRUE，则将向量中的 NA 值放到序列末尾
# 函数 order()可以返回元素排好序的索引，以其结果作为索引访问元素，正好是排好序的向量
# 函数rank()的返回值是该向量中对应元素的“排名”，参数“ties. method”用于设置 相同值的处理方法

x = c(1,5,8,2,9,7,4)
sort(x)
order(x) # 默认升序，排名第2的元素在原向量的在4个位置
x[order(x)] # 同sort(x)
rank(x) # 默认升序，第2个元素排在第4位
#函数 rev()可将序列进行反转，即把 1,2,3 变成 3,2,1。




### 1.2.2 矩阵(二维数据) 
#矩阵是用两个维度表示和访问的向量。因此，适用于向量的性质和方法大多也适用于矩阵
#矩阵也要求元素是同一类型，如数值矩阵、逻辑矩阵等

#1.创建矩阵
#函数 matrix()将一个向量创建为矩阵，其基本格式为:
# matrix(x, nrow, ncol, byrow, dimnames, ...)
# x:为数据向量作为矩阵的元素;
# nrow:设定行数;
# ncol:设定列数;
# byrow:设置是否按行填充，默认为 FALSE(按列填充); 
# dimnames:用字符型向量表示矩阵的行名和列名

matrix(c(1, 2, 3,
         4, 5, 6,
         7, 8, 9), nrow = 3, byrow = FALSE)

matrix(c(1, 2, 3,
         4, 5, 6,
         7, 8, 9), nrow = 3, byrow = TRUE)

#为矩阵的行列命名:
matrix(1:9, nrow = 3, byrow = TRUE,
         dimnames = list(c("r1","r2","r3"), c("c1","c2","c3")))

#也可以创建后再命名:
m1 = matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3)
rownames(m1) = c("r1", "r2", "r3")
colnames(m1) = c("c1", "c2", "c3")

#特殊矩阵:
  diag(1:4, nrow = 4) # 对角矩阵

#函数 as.vector()可将矩阵转化为向量，其元素是按列读取的。

# 2.访问矩阵子集 
#矩阵是用两个维度表示和访问的向量，可以用一个二维存取器[,]来访问，
#这类似于构建向量子集时用的一维存取器[]。 我们可以为每个维度提供一个向量来确定一个矩阵的子集
#方括号中的第 1 个参数是行选择器，第 2 个参数是列选择器
#与构建向量子集一样，我们可以在两个维度中使用数值向量、 逻辑向量和字符向量
m1[1,2] # 提取第1行，第2列的单个元素
m1[1:2, 2:4] # 提取第1至2行，第2至4列的元素
m1[c("r1","r3"), c("c1","c3")] # 提取行名为r1和r3，列名为c1和c3的元素

#若一个维度空缺，则选出该维度的所有元素:
#负数表示在构建矩阵子集时可排除该位置，这和向量中的用法一致:
#注意，矩阵是用两个维度表示和访问的向量，但它本质上仍然是向量。因此，向量的一维存取器也可以用来构建矩阵子集:
m1[3:7]

#由于向量只包含相同类型的元素，矩阵也是如此，因此它们的操作方式也相似。若输入一 个不等式，则返回同样大小的逻辑矩阵:
m1 > 3

#根据逻辑矩阵可以选择矩阵元素或赋值:
m1[m1 > 3] # 注意选出来的结果是向量 

# 3.矩阵运算
#A+B，A-B，A*B，A/B:矩阵四则运算要求矩阵同型，类似 MATLAB 中的点运算，
#分别将对应位置的元素做四则运算;
#A %*% B:矩阵乘法要求矩阵 A 的列数等于矩阵 B 的行数



# 1.2.3 多维数组(多维数据)
# 具体来说，多维数组就是一个维度更高(通常大于 2)、可访问的向量，是向量/矩阵向更高维度的自然推广
# 多维数组也要求元素是同一类型

#1.创建多维数组
#用函数 array()将一个向量创建为多维数组，基本格式为:
# array(x, dim, dimnames, ...)
# x:为数据向量作为多维数组的元素
# dim:设置多维数组各维度的维数
# dimnames:设置多维数组各维度的名称
a1 = array(1:24, dim = c(3, 4, 2))
a1

#也可以在创建数组时对每个维度进行命名:
a1 = array(1:24, dim = c(3, 4, 2),dimnames=list(c("r1","r2","r3"),
                                                c("c1","c2","c3","c4"), c("k1","k2")))

#或者创建之后再命名1:
a1 = array(1:24, dim = c(3, 4, 2))
dimnames(a1) = list(c("r1","r2","r3"),
                    c("c1","c2","c3","c4"), c("k1","k2"))

# 2.访问多维数组子集
# 第 3 个维度姑且称为“页”:
# 在想象多维数组时，为了便于形象地理解，可以将其维度依次想象成与“书”相关的概念:行、列、页、
# 本、层、架、室......
a1[2,4,2]
a1["r2","c4","k2"]
a1[1,2:4,1:2]
a1[,,2]
dim(a1)
# 提取第2行,第4列,第2页的元素
# 提取第r2行,第c4列,第k2页的元素
# 提取第1行,第2至4列,第1至2页的元素 # 提取第2页的所有元素
# 返回多维数组a1的各维度的维数



## 1.3 数据结构:列表、数据框、因子
### 1.3.1 列表
# 列表(list)可以包含不同类型的对象，甚至可以包括其他列表。列表的灵活性使得它非常有用。
# 例如，用 R 拟合一个线性回归模型，其返回结果就是一个列表，其中包含了线性回归的详细结果，
# 如线性回归系数(数值向量)、残差(数值向量)、QR 分解(包含一个矩阵和其他对象 的列表)等。
# 因为这些结果全都被打包到一个列表中，就可以很方便地提取所需信息，而无须 每次调用不同的函数。
# 列表最大的好处就是能够将多个不同类型的对象打包到一起，以便可以根据位置和名字访 问它们。

# 1.创建列表
# 可以用函数 list()创建列表。不同类型的对象可以放入同一个列表中。
# 例如，创建一个列表，包含 3 个成分:一个单元素的数值向量、一个两元素的逻辑向量和一个长度为 3 的字符向量:

l0 = list(1, c(TRUE, FALSE), c("a", "b", "c"))
l0

#可以在创建列表时，为列表的每个成分指定名字:
l1 = list(A = 1, B = c(TRUE, FALSE), C = c("a", "b", "c"))
l1

#也可以创建列表后再对列表成分命名或修改名字:
names(l1) = NULL # 移除列表成分的名字 
names(l1) = c("x","y","z")

#2.从列表中提取成分的内容 
#提取列表中某成分下的内容，最常用的方法是用$，通过成分名字来提取该成分下的内容:
l1$y
l1$m # 访问不存在的成分m, 将会返回NULL

#也可以用[[n]]来提取列表第 n 个成分的内容，n 也可以换成成分的名字:
l1[[2]] # 同l1[["y"]] 
#用[[]]提取列表中某个成分的内容则更加灵活，可用在函数调用中，通过参数来传递成分的名字或索引:

#3.提取列表子集
# R 语言也经常需要从列表中提取多个成分及其内容，由这些成分组成的列表构成了原列表 的一个子集。
# 就像提取向量和矩阵的子集一样，提取一个列表子集是用[]，可以取出列表中的一些成分， 作为一个新的列表。
# 在[]中可以用字符向量表示成分名字，用数值向量表示成分位置，或用逻辑向量指定是否 选择来取出列表成分。

l1["x"] # 同l1[1]
l1[c("x", "z")] # 同 l1[c(1, 3)], l1[c(TRUE, FALSE, TRUE)]
# 总之，[]用于提取对象的子集，类型仍是该对象;[[]]用于提取对象的内容(即下一级元素)

# 4.为列表的成分赋值
# 即先访问(提取)到列表的成分，再赋以相应的值。注意，若给一个不存在的成分赋值， 列表会自动地在对应名称或位置下增加一个新成分

l1$x = 0 # 将列表的成分x赋值为0 
#也可以同时给多个列表成分赋值:
l1[c("x", "y")] = list(x = "new value for y", y = c(3, 1))
#若要移除列表中的某些成分，只需赋值为 NULL: 
l1[c("z", "m")] = NULL

#5.列表函数
#用函数 as.list()可将向量转换成列表:
l2 = as.list(c(a = 1, b = 2))
l2

#通过去列表化函数 unlist()可将一个列表打破成分界线，强制转换成一个向量1: 
unlist(l2)

# 为了方便操作列表，tidyverse 系列中的 purrr 包提供了一系列列表相关的函数，建议读者查阅并使用。
# pluck():同[[]]提取列表中的元素。
# keep():保留满足条件的元素。
# discard():删除满足条件的元素。
# compact():删除列表中的空元素。
# append():在列表末尾增加元素。
# flatten():摊平列表(只摊平一层)。


# 1.3.2 数据框(数据表)
# R语言中用于统计分析的样本数据，都是按数据框类型操作的
# 数据框是指有若干行和列的数据集，它与矩阵类似，但并不要求所有列都是相同的类型
# 本质上讲，数据框就是一个列表，它的每个成分都是一个向量，并且长度相同，以表格的形式展现
# 总之，数据框是由列向量组成、有着矩阵形式的列表
# 数据框与常见的数据表是一致的:每一列代表一个变量属性，每一行代表一条样本数据

# R 中自带的数据框是 data.frame，建议改用更现代的数据框:tibble1。
# Hadley 在 tibble 包中引入了一种 tibble 数据框，以代替 data.frame，而且 tidyverse 包都是基于 tibble 数据框的。
# tibble 对比 data.frame 的优势如下所示。
# tibble()比 data.frame()做的更少:不改变输入变量的类型，不会改变变量名，不会创建行名。
# tibble对象的列名可以是R中的“非法名”:非字母开头、包含空格，但定义和使用
# 变量时都需要用反引号`括起来
# tibble 在输出时不自动显示所有行，避免数据框较大时显示出很多内容
# 用[]选取列子集时，即使只选取一列，返回结果仍是 tibble，而不自动简化为向量

#1.创建数据框
#用 tibble()根据若干列向量创建 tibble:
library(tidyverse) # 或tibble 
persons = tibble(
Name = c("Ken", "Ashley", "Jennifer"),
Gender = c("Male", "Female", "Female"),
Age = c(24, 25, 23),
Major = c("Finance", "Statistics", "Computer Science"))
persons

#用 tribble()通过按行录入数据的方式创建 tibble:
tribble(
  ~Name, ~Gender, ~Age, ~Major,
  "Ken", "Male", 24, "Finance",
  "Ashley", "Female", 25, "Statistics",
  "Jennifer", "Female", 23, "Computer Science")

#用 as_tibble()可将 data.frame 和 matrix 这种各成分等长度的 list 转换为 tibble
#将不等长的列表转化为数据框:
a = list(A = c(1, 3, 4), B = letters[1:4])
a

# lengths()获取list中每个成分的长度
map_dfc(a, `length<-`, max(lengths(a))) # map循环参阅1.6.2节

#数据框既是列表的特例，也是广义的矩阵，因此访问这两类对象的方式都适用于数据框
#例如与矩阵类似，对数据框的各列重命名，代码如下:
df = tibble(id = 1:4,
              level = c(0, 2, 1, -1),
              score = c(0.5, 0.2, 0.1, 0.5))
  
names(df) = c("id", "x", "y")

df

#2.提取数据框的元素、子集
#数据框是由列向量组成、有着矩阵形式的列表，可以用两种操作方式来访问数据框的元素和子集

#(1)以列表方式提取数据框的元素、子集 若把数据框看作由向量组成的列表，则可以沿用列表的操作方式来提取元素或构建子集
#例如，可以用 $ 按列名来提取某一列的值，或者用[[]]按照位置或列名提取。 
#例如，提取列名为 x 的值，并得到向量:

df$x # 同df[["x"]], df[[2]] 

#以列表形式构建子集完全适用于数据框，同时也会生成一个新的数据框
#提取子集的操作 符[]允许用数值向量表示列的位置，用字符向量表示列名，或用逻辑向量指定是否选择
#例如，提取数据框的一列或多列，可以得到子数据框:
df[1] # 提取第1列, 同df["id"]

df[1:2] # 同df[c("id","x")], df[c(TRUE,TRUE,FALSE)]
  
#(2)以矩阵方式提取数据框的元素、子集 以列表形式操作并不支持行选择，以矩阵形式操作则更加灵活
#若将数据框看作矩阵，其二维形式的存取器可以很容易地获取一个子集的元素，同时支持列选择和行选择
#换句话说，可以使用[i, j]指定行或列来提取数据框子集，[,]内可以是数值向量、字符向量或者逻辑向量
#若行选择器为空，则只选择列(所有行):
df[, "x"]
df[,c("x","y")]
# 同df[,2:3]

#若列选择器为空，则只选择行(所有列):
df[c(1,3),]

#同时选择行和列:
df[1:3, c("id","y")]

#根据条件筛选数据。例如用y >= 0.5筛选df的行，并选择id和y两列:
df[df$y >= 0.5, c("id","y")]

#按列名属于集合{x, y, w}来筛选df的列，并选择前两行: 
ind = names(df) %in% c("x","y","w")
df[1:2, ind]


#3.给数据框赋值
#给数据框赋值就是选择要赋值的位置，再准备好同样大小且格式匹配的数据，
#赋值给那些位置即可，同样有列表方式和矩阵方式

#(1)以列表方式给数据框赋值
#用 $ 或[[ ]]对数据框的某列赋值
df$y = c(0.6,0.3,0.2,0.4) # 同df[["y"]] = c(0.6,0.3,0.2,0.4)
#利用现有列，创建(计算)新列:
df$z = df$x + df$y
df

df$z = as.character(df$z) # 转换列的类型 df

#用[]可以对数据框的一列或多列进行赋值: 
df["y"] = c(0.8,0.5,0.2,0.4)
df[c("x", "y")] = list(c(1,2,1,0), c(0.1,0.2,0.3,0.4))

#(2)以矩阵方式给数据框赋值 以列表方式对数据框进行赋值时，也是只能访问列
#若需要更加灵活地进行赋值操作，可以通过矩阵方式进行
df[1:3,"y"] = c(-1,0,1)
df[1:2,c("x","y")] = list(c(0,0), c(0.9,1.0))

#4.一些有用的函数
#把函数 str()或 glimpse()作用在 R 对象上，可以显示该对象的结构:
str(persons)

#把 summary()作用在数据框或列表上，将生成各列或各成分的汇总信息: 
summary(persons)

#我们经常需要将多个数据框(或矩阵)按行或按列进行合并
#用函数 rbind()增加行(样本数据)，要求宽度(列数)相同
#用 cbind()函数增加列(属性变量)，要求高度(行数) 相同
#例如，向 persons 数据框中添加一个新记录: 
rbind(persons,
      tibble(Name = "John", Gender = "Male",
            Age = 25, Major = "Statistics"))

#向 persons 数据框中添加两个新列，分别表示每个人是否已注册及其手头的项目数量:
cbind(persons, Registered = c(TRUE, TRUE, FALSE), Projects = c(3, 2, 3))

#rbind()和 cbind()不会修改原始数据，而是生成一个添加了行或列的新数据框
#函数 expand.grid()可生成多个属性水平值的所有组合(笛卡儿积)形式的数据框: 
expand.grid(type = c("A","B"), class = c("M","L","XL"))


#1.3.3 因子
#数据(变量)可划分为:定量数据(数值型)、定性数据(分类型)，定性数据又分为名义型(无好坏顺序之分，如性别)、有序型(有好坏顺序之分，如疗效)
#R提供了因子(factor)这一数据结构(容器)，专门用来存放名义型和有序型的分类变量
#因子本质上是一个带有水平(level)属性的整数向量，其中“水平”是指事前确定可能取值的有限集合
#例如，性别有两个水平属性:男、女
#直接用字符向量也可以表示分类变量，但它只有字母顺序，不能规定想要的顺序，也不能表达有序分类变量
#所以，有必要把字符型的分类变量转化为因子型，这更便于对其做后续描述汇总、可视化、建模等
#1.创建与使用因子

# 函数 factor()用来创建因子，基本格式为:
# factor(x, levels, labels, ordered, ...)
# x:为创建因子的数据向量
# levels:指定因子的各水平值，默认为 x 中不重复的所有值
# labels:设置各水平名称(前缀)，与水平名称一一对应
# ordered:设置是否对因子水平排序，默认 FALSE 为无序因子，TRUE 为有序因子
# 该函数还包含参数 exclude:指定有哪些水平是不需要的(设为 NA)
# nmax 用于设定水平数的上限
# 若不指定参数 levels，则因子水平默认按字母顺序
# 比如，现有 6 个人的按等级划分的成绩数据，先以字符向量创建，并对其排序: 
x = c("优", "中", "良", "优", "良", "良") # 字符向量 x
sort(x) # 排序是按字母顺序

#它的顺序只能是字母顺序，如果想规定顺序:中、良、优，
#正确的做法就是创建因子，用 levels 指定想要的顺序:
x1 = factor(x, levels = c("中", "良", "优")) # 转化因子型
x1

as.numeric(x1) # x的存储形式: 整数向量

# 注意，不能直接将因子数据当字符型操作，需要用 as.character()转化
# 转化为因子型后，数据向量显示出来(外在表现)与原来是一样的，但这些数据的内在存 储已经变了
# 因子的内在存储与外在表现如图 1.8 所示
# 因子型是以整数向量存储的，将各水平值按照规定的顺序分别对应到整数
# 将原向量的各个值分别用相应的整数存储，输出和使用的时候再换回对应的水平值
# 整数是有顺序的，这样就相当于在不改变原数据的前提下规定了顺序，同时也节省了存储空间
# 注意，标签(labels)是因子水平(levels)的别名
# 变成因子型后，无论是排序、统计频数、绘图等，都有了顺序:
sort(x1)

table(x1)

ggplot(tibble(x1), aes(x1)) +
  geom_bar()

#所生成的条形图结果如图 1.9 所示，x 轴的条形顺序是想要的中、良、优
#图 1.8 因子的内在存储与外在表现 图 1.9 用因子控制条形顺序
#用 levels()函数可以访问或修改因子的水平值，这也将改变数据的外在表现:
x1 = factor(x, levels = c("中", "良", "优")) # 转化因子型 x1
levels(x1) = c("Fair", "Good", "Excellent") # 修改因子水平 x1

#有时候你可能更希望让水平的顺序与其在数据集中首次出现的次序相匹配，这时可以设置 参数levels = unique(x)
#转化为因子型的另一个好处是，可以“识错”:因子数据只认识出现在水平值中的值，对于 未出现在水平值中的值将被识别为 NA
#很多人将因子固有的顺序与有序因子混淆，二者不是一回事:上述反复提到的顺序，可称 为因子固有的顺序，
#正是有了它，才能方便地按想要的顺序进行排序、统计频数、绘图等;
#而 无序因子与有序因子，是与变量本身的数据类型相对应的，名义型(无顺序好坏之分的分类变 量)用无序因子存放，
#有序型(有顺序好坏之分的分类变量)用有序因子存放，该区分是用于 不同类型的数据，建模时适用不同的模型。
#示例的成绩数据是有好坏之分的，因此创建为有序因子: ## [1]优中良优良良
#如果对 x2 做排序、统计频数、绘图，你会发现与使用无序因子时没有任何区别，它们的区 别体现在对其建模时所适用的模型不同。

#2.有用函数
函数 table()可以统计因子各水平的出现次数(频数)，也可以统计向量中每个不同元素的出现次数，其
返回结果为命名向量。
table(x)
## x
## 良 优 中 ## 3 2 1
函数 cut()，用来做连续变量离散化:将数值向量切分为若干区间段，并返回因子。基本格式为: cut(x, breaks, labels, ...)
x:要切分的数值向量。
breaks:切分的界限值构成的向量，或表示切分段数的整数。
该函数还包含参数 right 用于设置区间段是否左开右闭，include.lowest 用于设置是否包含下界， ordered_result 用于设置是否对结果因子排序。
Age = c(23,15,36,47,65,53)
## [1] Middle Young  Middle Old    Old    Old
## Levels: Young Middle Old
函数 gl()用来生成有规律的水平值组合因子。对于多因素试验设计，用该函数可以生成多个因素完全组 合，基本格式为:
  gl(n, k, length, labels, ordered, ...)
n:为因子水平个数。
k:为同一因子水平连续重复次数。 length:为总的元素个数，默认为 n*k，若不够则自动重复。 labels:设置因子水平值。 ordered:设置是否为有序，默认为 FALSE。
x2 = factor(x, levels = c("中", "良", "优"), ordered = TRUE) x2
cut(Age, breaks = c(0,18,45,100),
    labels = c("Young","Middle","Old"))
异步社区cloudcHCO8tlw0iz(15725519632) 专享 请尊重版权

tibble(
  Sex = gl(2, 3, length = 12, labels = c("男","女")),
  Class = gl(3, 2, length = 12, labels = c("甲","乙","丙")),
  Score = gl(4, 3, length = 12, labels = c("优","良","中", "及格")))
## # A tibble: 12 x 3
##   Sex   Class Score
## <fct> <fct> <fct> ##1男 甲 优 ##2男 甲 优 ##3男 乙 优 ##4女 乙 良 ##5女 丙 良 ##6女 丙 良
## # ... with 6 more rows
3.forcats 包
tidyverse 系列中的 forcats 包是专门为处理因子型数据而设计的，forcats 包提供了 一系列操作因子的方便函数。
 as_factor():转化为因子，默认按水平值的出现顺序。
 fct_count():计算因子各水平频数、占比，可按频数排序。  fct_c():合并多个因子的水平。
 改变因子水平的顺序。
 fct_relevel():手动对水平值重新排序。  fct_infreq():按高频优先排序。
 fct_inorder():按水平值出现的顺序排序。  fct_rev():将顺序反转。
 fct_reorder():根据其他变量或函数结果排序(绘图时有用)。  修改水平。
 fct_recode():对水平值逐个重编码。
 fct_collapse():按自定义方式合并水平。
 fct_lump_*():将多个频数小的水平合并为其他。
 fct_other():将保留之外或丢弃的水平合并为其他。
 增加或删除水平。
 fct_drop():删除若干水平。
 fct_expand:增加若干水平。
 fct_explicit_na():为NA设置水平。
读者需要明白这样一个基本逻辑:操作因子是操作一个向量，该向量更多的时候是以数据 框的一列的形式存在的。我们来演示一下更常用的操作数据框中的因子列的方法，这会涉及数 据操作和绘图的语法，这部分知识在第 2~3 章才会讲到。你只需要知道大意并理解因子操作部 分即可。
mpg 列是汽车数据集，class 列是分类变量车型，先统计各种车型的频数，共有 7 类;对 该列做因子合并，合并为 5 类+Other 类，再统计频数，这里将频数少的类合并为 Other 类:
  count(mpg, class)
## # A tibble: 7 x 2
## class n
##   <chr>      <int>
## 1 2seater        5
## 2 compact       47
1.3 数据结构:列表、数据框、因子 25
异步社区cloudcHCO8tlw0iz(15725519632) 专享 请尊重版权

26 1 基础语法
##3 midsize 41
##4 minivan 11
##5 pickup 33
## 6 subcompact    35
## # ... with 1 more row
mpg1 = mpg %>%
  ## # A tibble: 6 x 2
  ## class n
  ##   <fct>      <int>
  ## 1 compact       47
  ## 2 midsize       41
  ## 3 pickup        33
  ## 4 subcompact    35
  ## 5 suv           62
  ## 6 Other         16
  若直接对 class 各类绘制条形图，是按水平顺序，此时频数会参差不齐;改用根据频数多 少进行排序，则条形图变得整齐易读，对比效果见图 1.10。
p1 = ggplot(mpg, aes(class)) +
  图 1.10 按频数排序的条形图 1.4 数据结构:字符串、日期时间
1.4.1 字符串
字符串是用双引号或单引号括起来的若干字符，建议用双引号，除非字符串中包含双引号。 字符串构成的向量，简称为字符向量。
字符串处理不是 R 语言的主要功能，但也是必不可少的，数据清洗、可视化等操作都会用到。
tidyverse 系列中的 stringr 包提供了一系列接口一致的、简单易用的字符串操作函数， 足以代替 R 自带的字符串函数。这些函数都是向量化的，即作用在字符向量上，对字符向量中 的每个字符串做某种操作。
mutate(class = fct_lump(class, n = 5))
count(mpg1, class)

geom_bar() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
p2 = ggplot(mpg, aes(fct_infreq(class))) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
library(patchwork)
p1 | p2



































             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             
             